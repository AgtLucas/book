<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="what.html"><strong>1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong>1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong>1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong>1.4.</strong> What tools will we use?</a></li></ul></li><li><a href="setup.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="osx.html"><strong>2.2.</strong> Mac OS X</a></li><li><a href="windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="booting-up.html"><strong>3.</strong> Booting up</a></li><li><ul class="section"><li><a href="multiboot-headers.html"><strong>3.1.</strong> Multiboot headers</a></li><li><a href="hello-world.html"><strong>3.2.</strong> Hello, world!</a></li><li><a href="making-an-iso.html"><strong>3.3.</strong> Making an ISO</a></li><li><a href="running-in-qemu.html"><strong>3.4.</strong> Running in QEMU</a></li><li><a href="automation-with-make.html" class="active"><strong>3.5.</strong> Automation with Make</a></li><li><a href="source-control-with-git.html"><strong>3.6.</strong> Source Control with Git</a></li></ul></li><li><a href="transitioning-to-long-mode.html"><strong>4.</strong> Transitioning to Long Mode</a></li><li><a href="a-rust-kmain.html"><strong>5.</strong> A Rust kmain()</a></li><li><a href="simple-vga.html"><strong>6.</strong> A simple VGA driver</a></li><li><a href="keyboard-input.html"><strong>7.</strong> Keyboard input</a></li><li class="spacer"></li><li class="affix"><a href="appendix/numeral-systems.html">Appendix A: Numeral Systems</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">intermezzOS</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Automation with Make</h1>
<p>Typing all of these commands out every time we want to build the project is
tiring and error-prone. It’s nice to be able to have a single command that
builds our entire project. To do this, we’ll use <code>make</code>. Make is a classic
bit of software that’s used for this purpose. At its core, <code>make</code> is fairly
simple:</p>
<ul>
<li>You create a file called <code>Makefile</code>.</li>
<li>In this file, you define <strong>rules</strong>. Rules are composed of three things:
<strong>targets</strong>, <strong>prerequisites</strong>, and <strong>commands</strong>.</li>
<li>Targets describe what you are trying to build.</li>
<li>Targets can depend on other targets being built before they can be built.
These are called ‘prerequisites’.</li>
<li>Commands describe what it takes to actually build the target.</li>
</ul>
<p>Let’s start off with a very straightforward rule. Specifically, the first step
that we did was to build the Multiboot header by running <code>nasm</code>. Let’s build a
<code>Makefile</code> that does this. Open a file called <code>Makefile</code> and put this in it:</p>
<pre><code class="language-make">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm
</code></pre>
<p>It’s <em>very</em> important that that <code>nasm</code> line uses a tab to indent. It can’t be
spaces. It has to be a tab. Yay legacy software!</p>
<p>Let’s try to run it before we talk about the details:</p>
<pre><code class="language-bash">$ make
nasm -f elf64 multiboot_header.asm
$
</code></pre>
<p>If you see this output, success! Let’s talk about this syntax:</p>
<pre><code class="language-text">target: prerequisites
        command
</code></pre>
<p>The bit before the colon is called a ‘target’. That’s the thing we’re trying to
build. In this case, we want to create the <code>multiboot_header.o</code> file, so we name
our target after that.</p>
<p>After the colon comes the ‘prerequisites’. This is a list of other targets that must
be built for this target to be built. In this case, building <code>multiboot_header.o</code>
requires that we have a <code>multiboot_header.s</code>. Because we have no rule describing how
to build this file, it existing is enough to satisfy the dependency.</p>
<p>Finally, on the next line, and indented by a tab, we have a ‘command’. This is the
shell command that you need to build the target.</p>
<p>Building <code>boot.o</code> is similar:</p>
<pre><code class="language-make">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm
</code></pre>
<p>Let’s try to build it:</p>
<pre><code class="language-bash">$ make
make: ‘multiboot_header.o’ is up to date.
$
</code></pre>
<p>Wait a minute, what? There’s two things going on here. The first is that <code>make</code> will build
the first target that you list by default. So a simple <code>make</code> will not build <code>boot.o</code>. To
build it, we can pass <code>make</code> the target name:</p>
<pre><code class="language-bash">$ make boot.o
nasm -f elf64 boot.asm
</code></pre>
<p>Okay, so that worked. But what about this ‘is up to date’ bit?</p>
<p>By defualt, <code>make</code> will keep track of the last time you built a particular
target, and check its last-modified-time against that time. If it hasn’t been
updated since it was built, then it won’t re-execute the build command. This is
a really powerful feature, especially as we grow. You don’t want to force the
entire project to re-build just because you edited one file; it’s nicer to only
re-build the bits that interact with it directly. A lot of the skill of <code>make</code>
is defining the right targets to make this work out nicely.</p>
<p>It would be nice if we could build both things with one command, but as it
turns out, our next target, <code>kernel.bin</code>, relies on both of these <code>.o</code> files,
so let’s write it first:</p>
<pre><code class="language-make">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>Let’s try building it:</p>
<pre><code class="language-bash">$ $ make kernel.bin
ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>Great! The <code>kernel.bin</code> target depends on <code>multiboot_header.o</code>, <code>boot.o</code>, and <code>linker.ld</code>. The
first two are the previous targets we defined, and <code>linker.ld</code> is a file on its own.</p>
<p>Let’s make <code>make</code> build the whole thing by default:</p>
<pre><code class="language-make">default: kernel.bin

multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>We can name targets whatever we want. In this case, <code>default</code> is a good
convention for the first rule, as it’s the default target. It relies on
the <code>kernel.bin</code> target, which means that we’ll build it, and as we previously
discussed, <code>kernel.bin</code> will build our two <code>.o</code>s.</p>
<p>Let’s try it out:</p>
<pre><code class="language-bash">$ make
make: Nothing to be done for ‘defualt’.
</code></pre>
<p>We haven’t edited our files, so everything is built. Let’s modify one. Open up
<code>multiboot_header.asm</code> in your editor, save it, and then run <code>make</code>:</p>
<pre><code class="language-bash">$ make
nasm -f elf64 multiboot_header.asm
ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>It re-built <code>multiboot_header.o</code>, and then <code>kernel.bin</code>. But it didn’t rebuild
<code>boot.o</code>, as we didn’t modify it at all.</p>
<p>Let’s add a new rule to build our iso. Rather than show the entire <code>Makefile</code>, I’m
going to start showing you what’s changed. First, we have to update our <code>default</code>
target, and then we have to write the new one:</p>
<pre><code class="language-make">default: isofiles

isofiles: kernel.bin grub.cfg
        mkdir -p isofiles/boot/grub
        cp grub.cfg isofiles/boot/grub
        cp kernel.bin isofiles/boot/
</code></pre>
<p>This is our first multi-command rule. <code>make</code> will execute all of the commands
that you list. In this case, to build the ISO, we need to create our <code>isofiles</code>
directory, and then copy <code>grub.cfg</code> and <code>kernel.bin</code> into the right place
inside of it.</p>
<p>Let’s try:</p>
<pre><code class="language-bash">$ make
mkdir -p isofiles/boot/grub
cp grub.cfg isofiles/boot/grub
cp kernel.bin isofiles/boot/
</code></pre>
<p>We’ve prepared ourselves to create the ISO. Let’s add a new rule to build <code>os.iso</code>:</p>
<pre><code class="language-make">defualt: os.iso

os.iso: isofiles
        grub-mkrescue -o os.iso isofiles
</code></pre>
<p>Building the ISO requires that the <code>isofiles</code> directory is created and
up-to-date.</p>
<p>Sometimes, it’s nice to add targets which describe a semantic. In this case, building
the <code>os.iso</code> target is the same as building the project. So let’s say so:</p>
<pre><code class="language-make">defualt: build

build: os.iso
</code></pre>
<p>The defualt action is to build the project, and to build the project, we need to build
<code>os.iso</code>. But what about running it? Let’s add a rule for that:</p>
<pre><code class="language-make">defualt: run

run: os.iso
        qemu-system-x86_64 -cdrom os.iso
</code></pre>
<p>You can choose the default here: do you want the defualt to be build, or run? Here’s what
each looks like:</p>
<pre><code class="language-bash">$ make     # build is the default
$ make run
</code></pre>
<p>or</p>
<pre><code class="language-bash">$ make       # run is the default
$ make build
</code></pre>
<p>I prefer to make <code>run</code> the default.</p>
<p>Finally, there’s another useful common rule: <code>clean</code>. The <code>clean</code> rule should remove all
of the generated files, and allow us to do a full re-build. As such it’s a bunch of <code>rm</code>
statements:</p>
<pre><code class="language-make">.PHONY: clean
clean: 
        rm -f multiboot_header.o
        rm -f boot.o
        rm -f kernel.bin
        rm -rf isofiles
        rm -f os.iso
</code></pre>
<p>What about that <code>.PHONY</code>? It’s a special, built-in target. Any dependencies of a <code>.PHONY</code>
target will always be considered fresh; in other words, running <code>make clean</code> will skip
checking if it’s been done already and just execute. In this case, this is what we want;
we want to nuke all the files, we don’t care when they were modified.</p>
<p>Here’s our final <code>Makefile</code>:</p>
<pre><code class="language-make">default: run

.PHONY: clean

multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o

isofiles: kernel.bin grub.cfg
        mkdir -p isofiles/boot/grub
        cp grub.cfg isofiles/boot/grub
        cp kernel.bin isofiles/boot/

os.iso: isofiles
        grub-mkrescue -o os.iso isofiles

build: os.iso

run: os.iso
        qemu-system-x86_64 -cdrom os.iso

clean: 
        rm -f multiboot_header.o
        rm -f boot.o
        rm -f kernel.bin
        rm -rf isofiles
        rm -f os.iso
</code></pre>
<p>You'll notice that there is a fair amount of repetition here. At first, that's
pretty okay: make can be a bit hard to understand, and while it has features
that let you de-duplicate things, they can also get unreadable really fast.</p>
<h2>Creating a build subdirectory</h2>
<p>Here's one example of a tweak we can do: <code>nasm</code> supports a <code>-o</code> flag, which
controls the name of the output file. We can use this to build <em>everything</em> in
a <code>build</code> subdirectory. This is nice for a number of reasons, but one of the
simplest is that all of our generated files will go in a single directory,
which means that it’s much easier to keep track of them: they’ll all be in one
place.</p>
<p>Let’s make some changes: More specifically, three of them:</p>
<pre><code class="language-make">build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o
</code></pre>
<p>The first one is the name of the rule. We have to add a <code>build/</code> in front of
the filename. This is because we’re going to be putting this file in that
directory now.</p>
<p>Second, we added another line: <code>mkdir</code>. We used <code>-p</code> to make directories
before, but in this case, the purpose of the flag is to not throw an error
if the directory already exists. We need to try to make this directory
when we build so that we can put our <code>.o</code> file in it!</p>
<p>Finally, we add the <code>-o</code> flag to <code>nasm</code>. This will create our output file in
that <code>build</code> directory, rather than in the current one.</p>
<p>With that, we’re ready to modify <code>boot.o</code> as well:</p>
<pre><code class="language-make">build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o
</code></pre>
<p>These changes are the same, just with <code>boot</code> instead of <code>multiboot_header</code>.</p>
<p>Next up: <code>kernel.bin</code>:</p>
<pre><code class="language-make">build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o
</code></pre>
<p>We append <code>build</code> in no fewer than <em>six</em> places. Whew! At least it’s
straightforward.</p>
<pre><code class="language-make">build/isofiles: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/
</code></pre>
<p>In a similar fashion, we prefix all the things with <code>build</code>.</p>
<pre><code class="language-make">build/os.iso: build/isofiles
        grub-mkrescue -o build/os.iso build/isofiles
</code></pre>
<p>Seeing a pattern yet? More prefixing.</p>
<pre><code class="language-make">run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso
</code></pre>
<p>... and here as well.</p>
<pre><code class="language-make">clean: 
        rm -rf build
</code></pre>
<p>Now some payoff! To get rid of our generated files, all we have to do is <code>rm</code>
our <code>build</code> directory. Much easier.</p>
<p>Here’s our final version:</p>
<pre><code class="language-make">default: run

.PHONY: clean

build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o

build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o

build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o

build/isofiles: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/

build/os.iso: build/isofiles
        grub-mkrescue -o build/os.iso build/isofiles

run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso

clean: 
        rm -rf build
</code></pre>
<p>We can go farther, and eventually, we will. But this is good enough for now.
Like I said, there’s a fine balance between keeping it DRY and making it
non-understandable.</p>
<p>Luckily, we’ll only be using Make for these assembly files. Rust has its own
build tool, Cargo, that we’ll integrate with Make. It’s a lot easier to use.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="running-in-qemu.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="source-control-with-git.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="running-in-qemu.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="source-control-with-git.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
