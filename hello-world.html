<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="what.html"><strong>1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong>1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong>1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong>1.4.</strong> What tools will we use?</a></li></ul></li><li><a href="setup.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="osx.html"><strong>2.2.</strong> Mac OS X</a></li><li><a href="windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="booting-up.html"><strong>3.</strong> Booting up</a></li><li><ul class="section"><li><a href="multiboot-headers.html"><strong>3.1.</strong> Multiboot headers</a></li><li><a href="hello-world.html" class="active"><strong>3.2.</strong> Hello, world!</a></li><li><a href="making-an-iso.html"><strong>3.3.</strong> Making an ISO</a></li><li><a href="running-in-qemu.html"><strong>3.4.</strong> Running in QEMU</a></li><li><a href="automation-with-make.html"><strong>3.5.</strong> Automation with Make</a></li><li><a href="source-control-with-git.html"><strong>3.6.</strong> Source Control with Git</a></li></ul></li><li><a href="transitioning-to-long-mode.html"><strong>4.</strong> Transitioning to Long Mode</a></li><li><a href="a-rust-kmain.html"><strong>5.</strong> A Rust kmain()</a></li><li><a href="simple-vga.html"><strong>6.</strong> A simple VGA driver</a></li><li><a href="keyboard-input.html"><strong>7.</strong> Keyboard input</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">intermezzOS</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Hello, world!</h1>
<p>Now that we’ve got the headers out of the way, let’s do the traditional first
program: Hello, world!</p>
<h2>The smallest kernel</h2>
<p>Our hello world will be just <em>20</em> lines of assembly code. Let’s begin.
Open a file called <code>boot.asm</code> and put this in it:</p>
<pre><code class="language-x86asm">start:
    hlt
</code></pre>
<p>You’ve seen the <code>name:</code> form before: it’s a <em>label</em>. This lets us name a line
of code. We’ll call this label <code>start</code>, which is the traditional name.
GRUB will use this convention to know where to begin.</p>
<p>The <code>hlt</code> statement is our first bit of ‘real’ assembly. So far, we had just
been declaring data. This is actual, executable code. It’s short for ‘halt’.
In other words, it ends the program.</p>
<p>By giving this line a label, we can call it, like a function. That’s what
GRUB does: “Call the function named <code>start</code>.” This function has just one
line: stop.</p>
<p>Unlike many other languages, you’ll notice that there’s no way to say if
this ‘function’ takes any arguments or not. We’ll talk more about that later.</p>
<p>This code won’t quite work on its own though. We need to do a little bit more
bookkeeping first. Here’s the next few lines:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    hlt
</code></pre>
<p>Three new bits of information. The first:</p>
<pre><code class="language-x86asm">global start
</code></pre>
<p>This says “I’m going to define a label <code>start</code>, and I want it to be available
outside of this file.” If we don’t say this, GRUB won’t know where to find its
definition. You can kind of think of it like a ‘public’ annotation in other
languages.</p>
<pre><code class="language-x86asm">section .text
</code></pre>
<p>We saw <code>section</code> briefly, but I told you we’d get to it later. The place where
we get to it is at the end of this chapter. For the moment, all you need to
know is this: code goes into a section named <code>.text</code>. Everything that comes
after the <code>section</code> line is in that section, until another <code>section</code> line.</p>
<pre><code class="language-x86asm">bits 32
</code></pre>
<p>GRUB will boot us into protected mode, aka 32-bit mode. So we have to specify
that directly. Our Hello World will only be in 32 bits. We’ll transition from
32-bit mode to 64-bit mode in the next chapter, but it’s a bit involved.
So let’s just stay in protected mode for now.</p>
<p>That’s it! We could theoretically stop here, but instead, let’s actually print
the “Hello world” text to the screen. We’ll start off with an ‘H’:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    hlt
</code></pre>
<p>This new line is the most complicated bit of assembly we’ve seen yet. There’s a
lot packed into this little line.</p>
<p>The first important bit is <code>mov</code>. This is short for <code>move</code>, and it sorta looks
like this:</p>
<pre><code class="language-text">mov size place, thing
</code></pre>
<p>Oh, <code>;</code> starts a comment, remember? So the <code>; H</code> is just for us. I put this
comment here because this line prints an <code>H</code> to the screen!</p>
<p>Yup, it does. Okay, so here’s why: <code>mov</code> copies <code>thing</code> into <code>place</code>. The amount
of stuff it copies is determined by <code>size</code>.</p>
<pre><code class="language-x86asm">;   size place      thing
;   |    |          |
;   V    V          V
mov word [0xb8000], 0x0248 ; H
</code></pre>
<p>“Copy one word: the numer <code>0x248</code> to ... some place.</p>
<p>The place is a hexidecimal number, but has square brackets <code>[]</code> around it.
Those brackets are special. They mean “the address in memory located by this
number.” In other words, we’re copying the number <code>0x0248</code> into the specific
memory location <code>0xb8000</code>. That’s what this line does.</p>
<p>Why? Well, we’re using the screen as a “memory mapped” device. Specific
positions in memory correspond to certain positions on the screen. And
the position <code>0xb8000</code> is one of those positions: the upper-left corner of the
screen.</p>
<p>Now, we are copying <code>0x0248</code>. Why this number? Well, it’s in three parts:</p>
<pre><code class="language-text"> __ background color
/  __foreground color
| /
V V  
0 2 48 &lt;- letter, in ASCII
</code></pre>
<p>We’ll start at the right. First, two numbers are the letter, in ASCII. <code>H</code> is
72 in ASCII, and 48 is 72 in hexidecimal: <code>(4 * 16) + 8 = 72</code>. So this will
write <code>H</code>.</p>
<p>The other two numbers are colors. There are 16 colors available, each with a
numer. Here’s the table:</p>
<pre><code>| Value | Color          |
|-------|----------------|
| 0x0   | black          |
| 0x1   | blue           |
| 0x2   | green          |
| 0x3   | cyan           |
| 0x4   | red            |
| 0x5   | magenta        |
| 0x6   | brown          |
| 0x7   | gray           |
| 0x8   | dark gray      |
| 0x9   | bright blue    |
| 0xA   | bright green   |
| 0xB   | bright cyan    |
| 0xC   | bright red     |
| 0xD   | bright magenta |
| 0xE   | yellow         |
| 0xF   | white          |
</code></pre>
<p>So, <code>02</code> is a black background with a green foreground. Classic. Feel free to
change this up, use whatever combination of colors you want!</p>
<p>So this gives us a <code>H</code> in green, over black. Next letter: <code>e</code>.</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    hlt
</code></pre>
<p>Lower case <code>e</code> is <code>65</code> in ASCII, at least, in hexidecimal. And <code>02</code> is our same
color code. But you’ll notice that the memory location is different.</p>
<p>Okay, so we copied four hexidecimal digits into memory, right? For our <code>H</code>.
<code>0248</code>. A hexidecimal digit has sixteen values, so two of them are 32. Since we
need one word for the colors, and one word for the <code>H</code>, that’s two words.
Hence, if our first memory position is at <code>0</code>, the second letter will start at
<code>2</code>.</p>
<p>This math gets easier the more often you do it. And we won’t be doing <em>that</em> much
more of it. There is a lot of working with hex numbers in operating systems work,
so you’ll get better as we practice.</p>
<p>With this, you should be able to get the rest of Hello, World. Go ahead and try
if you want: each letter needs to bump the location twice, and you need to look
up the letter’s number in hex.</p>
<p>If you don’t want to bother with all that, here’s the final code:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    mov word [0xb8004], 0x026c ; l
    mov word [0xb8006], 0x026c ; l
    mov word [0xb8008], 0x026f ; o
    mov word [0xb800a], 0x022c ; ,
    mov word [0xb800c], 0x0220 ; 
    mov word [0xb800e], 0x0277 ; w
    mov word [0xb8010], 0x026f ; o
    mov word [0xb8012], 0x0272 ; r
    mov word [0xb8014], 0x026c ; l
    mov word [0xb8016], 0x0264 ; d
    mov word [0xb8018], 0x0221 ; !
    hlt
</code></pre>
<p>Finally, now that we’ve got all of the code working, we can assemble our
<code>boot.asm</code> file with <code>nasm</code>, just like we did with the <code>multiboot_header.asm</code>
file:</p>
<pre><code class="language-bash">$ nasm -f elf64 boot.asm
</code></pre>
<p>This will produce a <code>boot.o</code> file. We’re almost ready to go!</p>
<h2>Linking it together</h2>
<p>Okay! So we have two different <code>.o</code> files: <code>multiboot_header.o</code> and <code>boot.o</code>.
But what we need is <em>one</em> file with both of them. Our OS doesn’t have the
ability to do anything yet, let alone load itself in two parts somehow. We just
want one big binary file.</p>
<p>Enter ‘linking’. If you haven’t worked in a compiled language before, you
probably haven’t had to deal with linking before. Linking is how we’ll turn
these two files into a single output: by linking them together.</p>
<p>Open up a file called <code>linker.ld</code>and put this in it:</p>
<pre><code class="language-text">ENTRY(start)

SECTIONS {
    . = 1M;

    .boot :
    {
        /* ensure that the multiboot header is at the beginning */
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }
}
</code></pre>
<p>This is a ‘linker script’. It controls how our linker will combine these
files into the final output. Let’s take it bit-by-bit:</p>
<pre><code class="language-text">ENTRY(start)
</code></pre>
<p>This sets the ‘entry point’ for this executable. In our case, we called our
entry point by the name people use: <code>start</code>. Remember? In <code>boot.s</code>? Same
name here.</p>
<pre><code class="language-text">SECTIONS {
</code></pre>
<p>Okay! I’ve been promising you that we’d talk about sections. Everything inside
of these curly braces is a section. We annotated parts of our code with
sections earlier, and here, in this part of the linker script, we will describe
each section by name and where it goes in the resulting output.</p>
<pre><code class="language-text">    . = 1M;
</code></pre>
<p>This line means that we will start putting sections at the one megabyte mark.
This is the conventional place to put a kernel, at least to start. Below one
megabyte is all kinds of memory-mapped stuff. Remember the VGA stuff? It
wouldn’t work if we mapped our kernel’s code to that part of memory... garbage
on the screen!</p>
<pre><code class="language-text">    .boot :
</code></pre>
<p>This will create a section named <code>boot</code>. And inside of it...</p>
<pre><code class="language-text">        *(.multiboot_header)
</code></pre>
<p>... goes every section named <code>multiboot_header</code>. Remember how we defined that
section in <code>multiboot_header.asm</code>? It’ll be here, at the start of the <code>boot</code>
section. That’s what we need for GRUB to see it.</p>
<pre><code class="language-text">    .text :
</code></pre>
<p>Next, we define a <code>text</code> section. The <code>text</code> section is where you put code.
And inside of it...</p>
<pre><code class="language-text">        *(.text)
</code></pre>
<p>... goes every section named <code>.text</code>. See how this is working? The syntax is a
bit weird, but it’s not too bad.</p>
<p>That’s it for our script! We can then use <code>ld</code> to link all of this stuff
together:</p>
<pre><code class="language-bash">$ ld --nmagic --output=kernel.bin --script=linker.ld multiboot_header.o boot.o
</code></pre>
<p>By running this command, we do a few things:</p>
<pre><code class="language-text">--nmagic
</code></pre>
<p>TODO: https://github.com/intermezzOS/book/issues/30</p>
<pre><code class="language-text">--output=kernel.bin
</code></pre>
<p>This sets the name of our output file. In our case, that’s <code>kernel.bin</code>. We’ll be using
this file in the next step. It’s our whole kernel!</p>
<pre><code class="language-text">--script=linker.ld
</code></pre>
<p>This is the linker script we just made.</p>
<pre><code class="language-text">multiboot_header.o boot.o
</code></pre>
<p>Finally, we pass all the <code>.o</code> files we want to link together.</p>
<p>That’s it! We’ve now got our kernel in the <code>kernel.bin</code> file. Next, we’re going to
make an ISO out of it, so that we can load it up in QEMU.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="multiboot-headers.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="making-an-iso.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="multiboot-headers.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="making-an-iso.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
