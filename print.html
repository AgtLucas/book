<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="what.html"><strong>1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong>1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong>1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong>1.4.</strong> What tools will we use?</a></li></ul></li><li><a href="setup.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="osx.html"><strong>2.2.</strong> Mac OS X</a></li><li><a href="windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="booting-up.html"><strong>3.</strong> Booting up</a></li><li><ul class="section"><li><a href="multiboot-headers.html"><strong>3.1.</strong> Multiboot headers</a></li><li><a href="hello-world.html"><strong>3.2.</strong> Hello, world!</a></li><li><a href="making-an-iso.html"><strong>3.3.</strong> Making an ISO</a></li><li><a href="running-in-qemu.html"><strong>3.4.</strong> Running in QEMU</a></li><li><a href="automation-with-make.html"><strong>3.5.</strong> Automation with Make</a></li><li><a href="source-control-with-git.html"><strong>3.6.</strong> Source Control with Git</a></li></ul></li><li><a href="transitioning-to-long-mode.html"><strong>4.</strong> Transitioning to Long Mode</a></li><li><a href="a-rust-kmain.html"><strong>5.</strong> A Rust kmain()</a></li><li><a href="simple-vga.html"><strong>6.</strong> A simple VGA driver</a></li><li><a href="keyboard-input.html"><strong>7.</strong> Keyboard input</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">intermezzOS</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1 class="center">intermezzOS</h1>
<p><img class="center" src="rhizome.jpg" alt="rhizome" /></p>
<p class="center">An operating system for learning</p>
<h2>Preface</h2>
<p>This book describes the intermezzOS project. intermezzOS is a hobby operating
system, specifically targeted at showing beginners how to get into operating
systems development. Rather than describe some sort of final OS, it instead
proceeds in a tutorial-like fashion, allowing you to implement intermezzOS
yourself, alongside the book.</p>
<p>The book assumes that you have programmed in some language before, but not any
particular one. In fact, people who have not done low-level programming before
are a specific target of this book; I’ll be explaining a lot of things that
other resources will just assume that you know.</p>
<p>intermezzOS is implemented in <a href="https://www.rust-lang.org/">Rust</a>, and some
assembly code. We’ll try to explain Rust along the way, but may refer you to
its documentation when things get tricky. This book isn’t <em>really</em> about
learning Rust, but you might accidentally along the way.</p>
<p>You can find all of this stuff <a href="https://github.com/intermezzOS/">on GitHub</a>.
This book is in the <code>book</code> repository, the kernel is in <code>kernel</code>, and the
website is there too. Feel free to open issues on the <a href="https://github.com/intermezzOS/rfcs">RFCs
repo</a> if you want to discuss things
in a general sense, and send bug reports and PRs to the appropriate repos
if you’d like to help with a particular component.</p>
<h2>The Story</h2>
<p>A long time ago, in college, my friends and I were working on a hobby operating
system, <a href="http://xomb.org">XOmB</a>. It was... tough. Frankly, while I learned a
lot, I was a pretty minor contributor. I got frustrated too easily. One day, I
found Ruby, and I was pretty much done with low-level programming. I had done
it most of my life, and I was bored. Bored, and sick of dealing with core
dumps.</p>
<p>Those details aren’t that important. What is important is that over the years,
I’ve always wanted to get back into this stuff. But the problem is this: there
are a lot of people who do hobby operating system work, but... I don’t like
their attitudes.</p>
<p>You see, a lot of people see low-level programming as some kind of superior,
only-for-the-smartest kind of thing. They have a puritanical world-view: “I
suffered to learn this, so you too must suffer to build character.” I think
that’s short sighted. Low level programming <em>is</em> difficult to get into, but
that says more about the teachers’ faults than the students’.</p>
<p>Anyway, as my professional life has moved back towards the low level, I’ve been
thinking about this topic a lot again. That’s when I found an awesome link:
<a href="http://os.phil-opp.com/multiboot-kernel.html">Writing an OS in Rust by Philipp Oppermann</a>. I cannot speak enough
about how awesome Phil’s tutorial is; it single-handedly inspired me to get
back into operating systems.</p>
<p>The big difference with Phil’s tutorial is that it doesn’t treat you as being
stupid for not knowing ‘the basics’. It doesn’t say “spend hours debugging this
thing, because I did.” It doesn’t insult you for being new. It just explains
the basics of a kernel.</p>
<p>It’s amazing how much a little bit of a framing can completely change the way
you see something. When the examples I found were all about how you have to be
an amazing rockstar ninja and we won’t give you all the code because you suck
if you can’t figure it out, I hated this stuff. When it was kind,
understanding, and helpful, I couldn’t get enough.</p>
<p>Once I got to a certain part in Phil’s tutorial, I started implementing stuff
myself. A lot of the initial code here is going to be similar to Phil’s.
But I’m going to write about it anyway. There’s a good reason for that:</p>
<blockquote>
<p>Writing is nature’s way of showing us how sloppy our thinking is.</p>
<ul>
<li>Leslie Lamport</li>
</ul>
</blockquote>
<p>By re-explaining things in my own words, I hope to understand it even better.
This is just a perpetual theme with me: I like teaching because it helps me
learn. I like writing because it helps me understand.</p>
<p>The first section of the book is going to be clear about where we’re following
Phil, and where we break off and go into our own little world. After the start,
things will end up diverging.</p>
<p>Furthermore, I will not commit to any kind of schedule for this project. It’s
going to be in my spare time, and I’m learning a lot of this as I go, too.</p>
<h2>The Name</h2>
<blockquote>
<p>The nomad has a territory; he follows customary paths; he goes from one point
to another; he is not ignorant of points (water points, dwelling points,
assembly points, etc.). But the question is what in nomad life is a principle
and what is only a consequence. To begin with, although the points determine
paths, they are strictly subordinated to the paths they determine, the
reverse happens with the sedentary. The water point is reached only in order
to be left behind; every point is a relay and exists only as a relay. A path
is always between two points, but the in-between has taken on all the
consistency and enjoys both an autonomy and a direction of its own. The life
of the nomad is the intermezzo.</p>
<p>Deleuze and Guattari, “A Thousand Plateaus”, p380</p>
</blockquote>
<p>If you’re not into particular kinds of philosophy, this quote won’t mean a lot.
Let’s look at the dictionary definition:</p>
<blockquote>
<p>An intermezzo, in the most general sense, is a composition which fits between
other musical or dramatic entities, such as acts of a play or movements of a
larger musical work.</p>
<p><a href="https://en.wikipedia.org/wiki/Intermezzo">https://en.wikipedia.org/wiki/Intermezzo</a></p>
</blockquote>
<p>I want this project to be about learning. Learning is often referred to as a
journey. You start off in ignorance and end in knowledge. In other words,
‘learning’ is that part in the middle, the in-between state.</p>
<p>The tricky thing about learning is, you never stop learning. Once you learn
something, there’s something new to learn, and you’re on a journey again.</p>
<p>If you want to learn a lot, then you’ll find yourself perpetually in the
middle.</p>
<p>There is another sense by which this name makes sense: as we’ll learn in the
beginning of the book, operating systems are largely about abstractions. And
abstractions are themselves ‘in the middle’, between what they’re abstracting
and who they are abstracting it for.</p>
<h2>Principles</h2>
<p>Here are the guiding principles of intermezzOS:</p>
<ul>
<li>We’re all actual people. Please treat each other as such.</li>
<li>We’re all here to learn. Let’s help each other learn, rather than being some
kind of vanguard of knowledge.</li>
<li>The only thing that matters about your language background is the amount you
may have to learn.</li>
<li>Everything must be documented, or it’s not done.</li>
</ul>
<p>And of course, everything related to this project is under the <a href="http://intermezzos.github.io/code-of-conduct.html">Code of
Conduct</a>.</p>
<h1>Background</h1>
<p>Before we get going, we should probably have some idea of where we’re headed.</p>
<h1>What is an OS?</h1>
<p>It’s actually kind of difficult to define what an operating system is. There
are a lot of different kinds of operating systems, and they all do different
kinds of things.</p>
<p>Some things are commonly bundled with operating systems, but are arguably not
part of the essence of what makes an OS an OS. For example, many operating
systems are often marketed as coming equipped with an web browser or email
client. Are web browsers and email clients essential to operating systems?
Many would argue the answer is no.</p>
<p>There are some shared goals we can find among all operating systems, however.
Let’s try this out as a working definition:</p>
<blockquote>
<p>An operating system is a program that provides a platform for other
programs. It provides two things to these programs: abstractions and
isolation.</p>
</blockquote>
<p>This is good enough for now. Let’s consider this a test for inclusion,
but not exclusion. In other words, things that fit this definition
<em>are</em> operating systems, but things that don’t may or may not be,
we don’t quite know.</p>
<h2>Creating abstractions</h2>
<p>There are many reasons to create a platform for other programs, but a
common one for operating systems is to abstract over hardware.</p>
<p>Consider a program, running on some hardware:</p>
<p><img alt="program on hardware" class="center" src="assets/program_hardware.png" /></p>
<p>This program will need to know <em>exactly</em> about what kind of hardware exists.
If you want to run it on a different computer, it will have to know exactly
about that computer too. And if you want to write a second program, you’ll
have to re-write a bunch of code for interacting with the hardware.</p>
<blockquote>
<p>All problems in computer science can be solved by another level of
indirection.</p>
<ul>
<li>David Wheeler</li>
</ul>
</blockquote>
<p>To solve this problem, we can introduce an abstraction:</p>
<p><img alt="program on os on hardware" class="center" src="assets/program_os_hardware.png" /></p>
<p>Now, the operating system can handle the details of the hardware, and provide
an API for it. A program can be written for that operating system’s API, and
can then run on any hardware that the operating system supports.</p>
<p>At some point, though, we developed many operating systems. Since operating
systems are platforms, most people pick one and have only that one on their
computer. So now we have a problem that looks the same, but is a bit
different: our program is now specific to an OS, rather than specific to
a particular bit of hardware.</p>
<p>To solve this, some programming languages have a ‘virtual machine.’ This
was a big selling point of Java, for example: the Java Virtual Machine.
The idea here is that we create a <em>virtual</em> machine on top of the <em>real</em>
machine.</p>
<p><img alt="program on vm " class="center" src="assets/program_vm_os_hardware.png" /></p>
<p>Now, you write programs for the Java Virtual Machine, which is then ported
to each operating system, which is then ported to all the hardware. Whew!</p>
<p>This, of course, leads to the collary to the previous maxim:</p>
<blockquote>
<p>...except for the problem of too many layers of indirection.</p>
<ul>
<li>Kevlin Henney</li>
</ul>
</blockquote>
<p>We now have a pattern:</p>
<ul>
<li>I have <code>A</code>.</li>
<li><code>A</code> is written explicitly for <code>X</code>...</li>
<li>... but I want to support <code>X</code> and <code>Y</code>,</li>
<li>so I put abstraction <code>B</code> in the middle.</li>
</ul>
<p>We will see this pattern over and over again. Hence ‘intermezzo’: abstractions
are always in the middle.</p>
<h2>Isolation</h2>
<p>Many of the abstractions provided are, as we discussed, abstractions over
hardware. And hardware often has a pretty serious restriction: only one
program can access the hardware at a time. So if our operating system is going
to be able to run multiple programs, which is a common feature of many
operating systems, we’ll also need to make sure that multiple programs cannot
access hardware at the same time.</p>
<p>This really applies to more than just hardware though: it also applies to
shared resources (e.g. memory). Once we have two programs, it would
be ideal to not let them mess with each other. Consider any sort of program that
deals with your password: if programs could mess with each other’s memory
and code, then a program could trivially steal your password from another program!</p>
<p>This is just one symptom of a general problem. It’s much better to isolate
programs from each other, for a number of different reasons. For now, we’ll
just consider isolation as one of our important jobs, as OS authors.</p>
<h3>Wait a minute...</h3>
<p>Here’s a question for you to ponder: if we didn’t provide isolation, isn’t that
just a poor abstraction? In other words, if we had an abstraction where we
could interact with other things being abstracted... isn’t that just a bad job
of doing the abstraction? And in that sense, is the only thing an operating
system does abstraction? Is the only thing everything does abstraction?</p>
<p>I don’t have answers for you. If you figure it out, let me know...</p>
<h1>What kinds of OS are there?</h1>
<p>Okay, so here’s the thing: operating systems are made up of a <em>lot</em> of components.
The core component is called a ‘kernel’. The non-kernel bits of an operating system
are collevtively called a ‘userland’. Typically a kernel has more direct access to the
machine than a userland and thus acts somewhat like a super user (with powers that even
‘sudo’ cannot give you). A kernel forms the basis of the abstractions and isolations.
So, as OS developers, when we categorize operating systems, we tend to categorize them
by what kinds of kernel they have.</p>
<p>Although you may be used to hearing the term ‘Linux’ used as a name for an
operating system, you may hear some people say, “It’s GNU/Linux, not Linux.”
That’s because virtually all Linux distributions today use a Linux kernel + a
GNU userland. So the GNU folks are a bit annoyed that the kernel gets all
the credit. By the same token, a lot of people say ‘the kernel’ when they mean
‘the Linux kernel.’ This gets an entirely different set of people mad.</p>
<p>Sometimes, it just seems like everything makes everyone mad.</p>
<p>Anyway...</p>
<p>At the start, our ‘operating system’ will be just the kernel, and so we’ll tend
to focus on kernels for the first part of our journey.</p>
<p>The way that we categorize different kernels largely comes down to “what is in
the kernel and what is in userspace.” Upon reading this, you might then think
the easiest kind of kernel to write is the smallest, where everything is in
userspace. After all, smaller should be easier, right? Well... that’s not
actually true. Or at least, it’s not clear that it’s true.</p>
<h2>Monolithic kernels</h2>
<p>First, we have ‘monolithic kernels’. ‘Mono’ meaning ‘one’. One big ‘ol kernel.
Most real-world kernels are monolithic kernels, or at least, pretend to be.
Don’t worry about it. Linux, for example, is a monolithic kernel.</p>
<p>This means that monolithic kernels are kind of ‘the default’. Other kernels
usually define themselves by solving some kind of problem that monolithic
kernels have.</p>
<p>If a monolithic kernel were a web application, it would be a big ‘ol Rails
application. One repository. A million subdirectories. It may be a big ball
of mud, but it pays the bills.</p>
<h2>Microkernels</h2>
<p>Microkernels are, well, micro. Smaller. A lot of the functionality that’s typically in
the kernel is in userspace instead. This is a good idea in theory, but
historically, microkernels have had issues. All that communication has
overhead, which makes them slower.</p>
<p>Mach, the kernel that Mac OS X uses, is a microkernel. Well, sort of. It ended
up being one, but Mac OS X uses a version of Mach from before that work was
done... so it’s a bit blurry.</p>
<p>If a microkernel were a web application, it would be a microservice. And a
bunch of the other stuff that’s in kernel space in a monolithic kernel are
other microservices, but in userspace instead. It’s a bit cooler than a single
monolithic web app by itself, and the communication is nice for flexibility’s
sake, but has some overhead.</p>
<h2>Exokernels &amp; Unikernels</h2>
<p>These two kinds of operating systems are closely related, but it’s a bit harder
to dig into what exactly makes them different. Unikernels have one
easy-to-describe feature: they only run one single program at a time.
Exokernels are ‘more micro than micro’, but the details aren’t important right
now.</p>
<p>The important thing to know here is that there are a lot of other kinds of
designs than just monolithic vs. micro. There’s a lot of stuff to learn!</p>
<h1>What kind are we making?</h1>
<p>So, given all these kinds of operating systems, what kind are we making?</p>
<p>The answer is “it doesn’t even matter at first.” There’s some commonality in
almost all of these styles of operating systems, and we have to get all that
done before we even make those decisions.</p>
<p>Secondly, we could waste a <em>lot</em> of time trying to design our perfect OS. And
then never actually build it. Remember, the goal here is <em>to learn</em>, not <em>to
make the best OS that ever existed</em>. So really, what it ends up looking like
just doesn’t really matter at all. Most hobby operating system projects die
quite young.</p>
<p>Let’s focus on the <em>doing</em>, and less on the categorization, planning, and
being. A nice thing about operating systems is that there’s a lot of freedom of
direction. To tie it back into the example earlier, Phil’s tutorial starts
going into memory-management after getting printing to the screen going. We’ll
be going into keyboards first instead. There are, of course, some dependencies,
but there’s also a lot of freedom.</p>
<h1>What tools will we use?</h1>
<p>Before we can make a kernel, we need to figure out the tools we’re going to
use. The first question, of course, is what programming language?</p>
<p>In our case, we’re going to use two. The first one is the language that
<em>every</em> kernel must use: assembly language.</p>
<h2>Assembly</h2>
<p>Assembly language gives us direct access to a specific machine. If the basis of
computer science is abstraction, the very bottom of the software abstraction layer
is assembly. Below it lies only hardware and physics.</p>
<p>Assembly language looks like this:</p>
<pre><code class="language-x86asm">; foo.asm

section .data
global _start

_start:
    mov rax, 0
loop:
    add rax, 1
    cmp rax, 10
    jne loop

    mov rbx, rax
    mov rax, 1
    int 80h
</code></pre>
<p>This is a little program in assembly language. If it looks totally alien to you,
don't worry. We'll be taking assembly language step by step.</p>
<p>We can run it like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 foo.asm # assemble into foo.o
$ ld foo.o              # link into a.out
$ ./a.out               # run it
$ echo $?               # print out the exit code
10
$
</code></pre>
<p>You can write entire kernels in assembly if you want to. It’s not as bad as it
may sound. At the very beginning, we will <em>have</em> to use assembly. But not very
much. It takes about 100 lines total, to start. Completely manageable.</p>
<h2>Rust</h2>
<p>We will augment our assembly with code written in
<a href="https://www.rust-lang.org/">Rust</a>. In fact, we will be trying to get to
Rust-land as quickly as we possibly can. Rust is a really great programming
language, and it’s pretty great for writing operating systems. It has some
rough edges, but they’re not too big of a deal.</p>
<p>Rust will allow us to write:</p>
<pre><code class="language-rust">// foo.rs

use std::process;

fn main() {
    let mut a = 0;

    for _ in 0..10 {
        a = a + 1;
    }

    process::exit(a);
}
</code></pre>
<p>This does the same thing as our assembly code:</p>
<pre><code class="language-bash">$ rustc foo.rs # compile our Rust code to foo
$ ./foo        # run it
$ echo $?      # print out the exit code
10
$
</code></pre>
<p>That Rust code probably looks more like a programming language you’ve used in
the past. It’s a lot nicer to write complex things in a higher-level
programming language like Rust. That said, virtually all languages are
higher-level than assembly, so that’s not saying all that much. Rust is still a
low-level language by many standards.</p>
<p>So why choose Rust? Well, I’m picking it for two reasons:</p>
<ol>
<li>I love it.</li>
<li>There aren’t a lot of kernels in it yet.</li>
</ol>
<p>There are a suprising number of people working on kernels in Rust. But since
it’s a newer language, there aren’t nearly as many as for older, more
established languages.</p>
<h2>Do I need to be a wizard?</h2>
<p>No, you do not. A common theme of this project is “this is all we’ll need to
know about this topic for now.” There’s no reason that you need to absolutely
master everything before going forward. For example, in order to get Rust
going, we need only about 100 lines of assembly, as mentioned above. Do you
need to be a complete expert in assembly language to understand those well
enough to keep going? Not at all. Will learning more about it help? Absolutely!</p>
<p>There’s nobody that’s monitoring your credentials to see if you’re allowed to
move on. Do it at your own pace. Skip stuff. Come back when you don’t
understand what’s going on. Try it, wait a week, and then try it again.</p>
<p>There’s no wrong way to do this stuff, including by being a beginner. Everyone
was once. Don’t let anyone discourage you.</p>
<h1>Setting up a development environment</h1>
<p>Frankly, one of the hardest parts of starting an operating system is getting a
development environment going. Normally, you’re doing work on the same
operating system you’re developing for, and we don’t have that luxury. Yet!</p>
<p>There is a convention called a ‘target triple’ to describe a particular
platform. It’s a ‘triple’ because it has three parts:</p>
<pre><code class="language-text">arch-kernel-userland
</code></pre>
<p>So, a target triple for a computer which has an x86-64 bit processor running a
Linux kernel and the GNU userland would look like this:</p>
<pre><code class="language-text">x86_64-linux-gnu
</code></pre>
<p>However, it can also be useful to know the operating system as well, and so
the ‘triple’ part can be extended to include it:</p>
<pre><code class="language-text">x86_64-unknown-linux-gnu
</code></pre>
<p>This is for some unknown Linux. If we were targeting Debian specifically, it
would be:</p>
<pre><code class="language-text">x86_64-debian-linux-gnu
</code></pre>
<p>Since it’s four parts, it’s called a ‘target’ rather than a ‘target triple’,
but you’ll still hear some people call it a triple anyway.</p>
<p>Kernels themselves don’t need to be for a specific userland, and so you’ll
see ‘none’ get used:</p>
<pre><code class="language-text">x86_64-unknown-none
</code></pre>
<h2>Hosts &amp; Targets</h2>
<p>The reason that they’re called a ‘target’ is that it’s the architecture you’re
compiling <em>to</em>. The architecture you’re compiling <em>from</em> is called the ‘host
architecture’.</p>
<p>If the target and the host are the same, we call it ‘compiling’. If they are
different, we call it ‘cross-compiling’. So you’ll see people say things like</p>
<blockquote>
<p>I cross-compiled from x86_64-linux-gnu to x86-unknown-none.</p>
</blockquote>
<p>This means that the computer that the developer was using was a 64-bit
GNU/Linux machine, but the final binary was for a 32-bit x86 machine with no
OS.</p>
<p>So we need a slightly special environment to build our OS: we need to
cross-compile from whatever kind of computer we are using to our new target.</p>
<h2>Cheat codes</h2>
<p>... but we can also cheat. It’s okay to cheat. Well, in this case, it’s really
only okay at the start. We’ll eventually <em>have</em> to cross-compile, or things
will go wrong.</p>
<p>Here’s the cheat: if you are developing on an x86_64 Linux machine, and you’re
not using any special Linux kernel features, then the difference between
<code>x86_64-linux-gnu</code> and <code>x86_64-unknown-none</code> is really just theoretical. It
will still technically <em>work</em>. For now.</p>
<p>This is a common pitfall with new operating system developers. They’ll start
off with the cheat, and it will come back to haunt them later. Don’t worry;
I will actually show you how to fix things before they go wrong. Knowing the
difference here is still useful.</p>
<h1>Linux</h1>
<p>Here are the tools we’re going to need:</p>
<ul>
<li>Rust</li>
<li><code>nasm</code></li>
<li><code>ld</code></li>
<li><code>grub-mkrescue</code> + <code>xorriso</code></li>
<li><code>qemu</code></li>
</ul>
<p>To install Rust, check out <a href="https://github.com/brson/multirust">multirust</a>.</p>
<p>Once you have it installed, grab a nightly build:</p>
<pre><code class="language-bash">$ multirust update PUT NIGHTLY HERE
$ multirust default PUT NIGHTLY HERE
</code></pre>
<p>TODO: https://github.com/intermezzOS/book/issues/26</p>
<p>To install the other tools, on Debian:</p>
<pre><code class="language-bash">$ sudo apt-get install nasm xorriso qemu
</code></pre>
<h1>Mac OS X</h1>
<p>For now, the easiest way to get going is to install Linux on a virtual
machine, and follow the Linux instructions.</p>
<p>I hope to have better instructions for OS X soon; since I don’t have a
computer that runs it, I need to figure it out first. If you know how,
this would be a great way to <a href="https://github.com/intermezzOS/book">contribute</a></p>
<h1>Windows</h1>
<p>For now, the easiest way to get going is to install Linux on a virtual
machine, and follow the Linux instructions.</p>
<p>I hope to have better instructions for Windows soon; since I don’t have a
computer that runs it, I need to figure it out first. If you know how, this
would be a great way to <a href="https://github.com/intermezzOS/book">contribute</a></p>
<h1>Booting up</h1>
<p>We’ve got some of the theory down, and we’ve got a development environment
going. Let’s get down to actually writing some code, shall we?</p>
<p>Our first task is going to be the same as in any programming language: Hello
world! It’s going to take a <em>teeny</em> bit more code than in many languages. For
example, here’s “Hello, World!” in Ruby:</p>
<pre><code class="language-ruby">puts &quot;Hello, world!&quot;
</code></pre>
<p>Or in C:</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main(void) {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<p>But it’s not actually <em>that</em> much more work. It’s going to take us <em>28 lines</em>
to get there. And instead of a single command to build and run, like Ruby:</p>
<pre><code class="language-bash">$ ruby hello_world.rb
</code></pre>
<p>It’s going to initially take us six commands to build and run our hello world
kernel. Don’t worry, the next thing we’ll do is write a script to turn it back
into a single command.</p>
<h1>Multiboot headers</h1>
<p>Let’s get going! The very first thing we’re going to do is create a ‘multiboot
header’. What’s that, you ask? Well, to explain it, let’s take a small step
back and talk about how a computer boots up.</p>
<p>One of the amazing and terrible things about the x86 architecture is that it’s
maintained backwards compatibility throughout the years. This has been a
competitive advantage, but it’s also meant that the boot process is largely a
pile of hacks. Each time a new iteration comes out, a new step gets added to
the process. That’s right, when your fancy new computer starts up, it thinks
it’s an 8086 from 197?. And then, through a succession of steps, we transition
through more and more modern architectures until we end at the latest and
greatest.</p>
<p>The first mode is called ‘real mode’. This is a 16 bit mode that the original
x86 chips used. The second is ‘protected mode’. This 32 bit mode adds new
things on top of real mode. It’s called ‘protected’ because real mode sort of
let you do whatever you wanted, even if it was a bad idea. Protected mode was
the first time that the hardware enabled certain kinds of protections that allow
us to exercise more control around such things as RAM. We’ll talk more about
those details later.</p>
<p>The final mode is called ‘long mode’, and it’s 64 bits. Well, that’s actually a
lie: there’s two. Initially, you’re not in long mode, you’re in ‘compatibility
mode’. You see, when the industry was undergoing the transition from 32 to 64
bits, there were two options: the first was Intel’s Itanium 64-bit
architecture. It did away with all of the stuff I just told you about. But that
meant that programs had to be completely recompiled from scratch for the new
chips. Intel’s big competitor, AMD, saw an opportunity here, and released a new
set of chips called amd64. These chips were backwards compatible, and so you
could run both 32 and 64 bit programs on them. Itanium wasn’t compelling enough
to make the pain worth it, and so Intel released new chips that were compatible
with amd64. The resulting architecture was then called x86_64, the one we’re
using today. The moral of the story? Intel tried to save you from all of the
stuff we’re about to do, but they failed. So we have to do it.</p>
<p>Where was I... oh yes. Compatibility mode. So when you initially transition
to long mode, you’re not in <em>true</em> long mode; you’re in compatibility mode.
This is the ‘it all both works’ mode. From there, we can transition to
actual, honest-to-goodness long mode.</p>
<p>So that’s the task ahead of us: make the jump up the ladder and get to
long mode. We can do it! Let’s talk more details.</p>
<h2>Firmware and the BIOS</h2>
<p>So let's begin by turning the power to our computer on.</p>
<p>When we press the power button, electricity starts running, and a special piece of
software, known as the BIOS in Intel land, automatically runs.</p>
<p>With the BIOS we're already in the land of software, but unlike software that
you may be used to writing, the BIOS comes bundled with its computer and is located in
<em>r</em>ead-<em>o</em>nly <em>m</em>emory (ROM). While changing or updating stuff in ROM
is possible, it's not something you can do by invoking your favorite
package manager or by downloading something from some website. In fact some ROM
is literally hardwired into the computer and cannot be changed without
physically swapping it out. This makes sense here. The BIOS and the
computer are lifetime partners. Their existence doesn't make much sense without
each other.</p>
<p>One of the first things the BIOS does is run a ‘POST’ or <em>p</em>ower-<em>o</em>n <em>s</em>elf-<em>t</em>est
which checks for the availability and integrity of all the pieces of hardware that
the computer needs including the BIOS itself, CPU registers, RAM, etc. If you've
ever heard a computer beeping at you as it boots up, that's the POST reporting
its findings.</p>
<p>Assuming no problems are found, the BIOS starts the real booting process.</p>
<p>For a while now most comercial computer manufacturers have hidden their BIOS
booting process behind some sort of splash screen. It's usually possible to see the
BIOS' logs by pressing some collection of keys when your computer is starting up.</p>
<p>The BIOS also has a menu where you can see information about the computer
like CPU and memory specs and all the hardware the BIOS detected like hard drives
and CD and DVD drives. Typically this menu is accessed by pressing some other
weird collection of keyboard keys while the computer is attempting to boot.</p>
<p>Next, the BIOS automatically finds a ‘bootable drive’ by looking in certain
pre-determined places like the computer's hard drive and CD and DVD drives.
A drive is ‘bootable’ if it contains software that can finish the booting
process. In the BIOS menu you can usually change in what order the BIOS looks
for bootable drives or tell it to boot from a specific drive.</p>
<p>The BIOS knows it's found a bootable drive by looking at the first few kilobytes
of the drive and looking for some magical numbers set in that drive's
memory. This won't be the last time some magical numbers or hacky sounding things
are used on our way to building an OS. Such is life at such a low level...</p>
<p>When the BIOS has found its bootable drive, it loads part of the drive into
memory and transfers execution to it. With this process, we move away from what
comes dictated by the computer manufacturer and move ever closer to getting our
OS running.</p>
<h2>Bootloaders</h2>
<p>The part of our bootable drive that gets executed is called a ‘bootloader’,
since it loads things at boot time. The bootloader’s job is to take our kernel,
put it into memory, and then transition control to it.</p>
<p>Some people start their operating systems journey by writing a bootloader. We
will not be doing that. Frankly, this whole startup process is more of an
exercise in reading manuals and understanding the history of esoteric hardware
than it is anything else. That stuff may interest you, and maybe someday we’ll
come back and write a bootloader of our own.</p>
<p>In the interest of actually getting around to implementing a kernel, instead, we’ll
use an existing bootloader: GRUB.</p>
<h2>GRUB and Multiboot</h2>
<p>GRUB stands for ‘<em>gr</em>and <em>u</em>nified <em>b</em>ootloader’, and it’s a common one for
GNU/Linux systems. GRUB implements a specification called Multiboot, which is a
set of conventions for how a kernel should get loaded into memory. By following
the Multiboot specification, we can let GRUB load our kernel.</p>
<p>The way that we do this is through a ‘header’. We’ll put some information in a
format that multiboot specifies right at the start of our kernel. GRUB will
read this information, and follow it to do the right thing.</p>
<p>One other advantage of using GRUB: it will handle the transition from real mode
to protected mode for us, skipping the first step. We don’t even need to know
anything about all of that old stuff. If you’re curious about the kinds of
things you would have needed to know, put “A20 pin” into your favorite search
engine, and get ready to cry yourself to sleep.</p>
<h2>Writing our own Multiboot header</h2>
<p>I said we were gonna get to the code, and then I went on about more history.
Sorry about that! It’s code time for real! Let’s make a directory to contain
our project:</p>
<pre><code class="language-bash">$ mkdir intermezzOS
$ cd intermezzOS
</code></pre>
<p>A fun way to follow along is to pick a different name for your kernel, and
then change it as we go. Call your kernel whatever you want. intermezzOS was
almost called ‘Nucleus’, until I found out that there’s already a kernel with
that name that’s installed on billions of embedded devices. Whoops!</p>
<p>Inside that directory, make a new file called <code>multiboot_header.asm</code>, and
open it in your favorite editor. I use <code>vim</code>, but you should feel free to use
anything you’d like.</p>
<pre><code class="language-bash">$ touch multiboot_header.asm
$ vim multiboot_header.asm
</code></pre>
<p>Two notes about this: first of all, we’re just making this source file in the
top level. Don’t worry, we’ll clean house later. Remember: we’re going to build
stuff, and <em>then</em> abstract it afterwards. It’s easier to start with a mess and
clean it up than it is to try to get it perfect on the first try.</p>
<p>Second, this is a <code>.asm</code> file, which is short for ‘assembly’. That’s right, we’re
going to write some assembly code here. Don’t worry! It’s not super hard.</p>
<h3>An aside about assembly</h3>
<p>Have you ever watched Rich Hickey’s talk “Simple vs. Easy”? It’s a wonderful talk.
In it, he draws a distinction between these two words, which are commonly used as
synonyms.</p>
<p>TODO https://github.com/intermezzOS/book/issues/27</p>
<p>Assembly coding is simple, but that doesn’t mean that it’s easy. We’ll be doing
a little bit of assembly programming to build our operating system, but we
don’t need to know <em>that much</em>. It is completely learnable, even for someone
coming from a high-level language. You might need to practice a bit, and take
it slow, but I believe in you. You’ve got this.</p>
<h3>The Magic Number</h3>
<p>Our first assembly file will be almost entirely <em>data</em>, not code. Here’s the
first line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
</code></pre>
<p>Ugh! Gibberish! Let’s start with the semicolon (<code>;</code>). It’s a comment, that
lasts until the end of the line. This particular comment says ‘magic number’.
You’ll be seeing a lot of magic numbers in your operating system work. The idea
of a magic number is that it’s completely and utterly arbitrary. It doesn’t mean
anything. It’s just magic. The very first thing that the multiboot specification
requires is that we have the magic number <code>0xe85250d6</code> right at the start.</p>
<p>What’s the value in having an arbitrary number there? Well, it’s a kind of safeguard
against bad things happening. This is one of the ways in which we can check that
we actually have a real multiboot header. If it doesn’t have the magic number,
something has gone wrong, and we can throw an error.</p>
<p>I have no idea why it’s <code>0xe85250d6</code>, and I don’t need to care. It just is.</p>
<p>Finally, the <code>dd</code>. It’s short for ‘define double word’. It
declares that we’re going to stick some 32-bit data at this location. Very
straightforward.</p>
<h3>The mode code</h3>
<p>Okay, time to add a second line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
dd 0          ; protected mode code
</code></pre>
<p>This is another form of magic number. We want to boot into protected mode, and
so we put a zero here, using <code>dd</code> again. If we wanted GRUB to do something
else, we could look up another code, but this is the one that we want.</p>
<h3>Header length</h3>
<p>The next thing that’s required is a header length. We could use <code>dd</code> and count
out exactly how many bytes that our header is, but there’s two reasons why
we’re not doing that:</p>
<ol>
<li>Computers should do math, not people.</li>
<li>We’re going to add more stuff, and we’d have to recalculate this number each
time. Or wait until the end and come back. See #1.</li>
</ol>
<p>Here’s what this looks like:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length
header_end:
</code></pre>
<p>You don’t have to align the comments if you don’t want to. I usually don’t, but
it looks nice and after we’re done with this file, we’re not going to mess with
it again, so we won’t be constantly re-aligning them in the future.</p>
<p>The <code>header_start:</code> and <code>header_end:</code> things are called ‘labels’. Labels let
us use a name to refer to particular part of our code. Our third <code>dd</code> line
uses those two labels to do some math: the header length is the value of
<code>header_end</code> minus the value of <code>header_start</code>. When we compile this assembly
code, the assembler will do this calculation for us. No need to figure out
how many bytes there are by hand. Awesome.</p>
<p>You’ll also notice that I indented the <code>dd</code> statements. Usually, labels go in
the first column, and you indent actual instructions. How much you indent is up
to you; it’s a pretty flexible format.</p>
<h3>The Checksum</h3>
<p>The fourth field multiboot requires is a ‘checksum’. The idea is that we sum up
some numbers, and then use that number to check that they’re all what we
expected things to be. It’s similar to a hash, in this sense: it lets us and GRUB
double-check that everything is accurate.</p>
<p>Here’s the checksum:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))
header_end:
</code></pre>
<p>Again, we’ll use math to let the computer calculate the sum for us. We add up
the magic number, the mode code, and the header length, and then subtract it
from a big number. <code>dd</code> then puts that value into this spot in our file.</p>
<p>TODO: https://github.com/intermezzOS/book/issues/28</p>
<h3>Ending tag</h3>
<p>Finally, we have one more required bit: the end tag. it looks like this:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>Here we use <code>dw</code> to define a ‘word’ instead of just data. A word is 2
bytes on the x86_64 architecture. The multiboot specification demands that this
be exactly a word. You’ll find that this is super common in operating systems:
the exact size and amount of everything matters. It’s just a side-effect of
working at a low level.</p>
<p>TODO: https://github.com/intermezzOS/book/issues/29</p>
<h3>The Section</h3>
<p>We have one last thing to do: add a ‘section’ annotation. We’ll talk more about
sections later, so for now, just put what I tell you at the top of the file.</p>
<p>Here’s the final file:</p>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>That’s it! Congrats, you’ve written a multiboot compliant header. It’s a lot of
esoterica, but it’s pretty straightforward once you’ve seen it a few times.</p>
<h2>Assembling with <code>nasm</code></h2>
<p>We can’t use this file directly, we need to turn it into binary. We can use a
program called an ‘assembler’ to ‘assemble’ our assembly code into binary code.
It’s very similar to using a ‘compiler’ to ‘compile’ our source code into
binary. But when it’s assembly, people often use the more specific name.</p>
<p>We will be using an assembler called <code>nasm</code> to do this. You should invoke
<code>nasm</code> like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 multiboot_header.asm
</code></pre>
<p>The <code>-f elf64</code> says that we want to output a <em>f</em>ile with the type <code>elf64</code>.
ELF is a particular executable format that’s used by various UNIX systems,
and we’ll be using it too. There are other formats, but ELF is pretty good.</p>
<p>After you run this command, you should see a <code>multiboot_header.o</code> file in
the same directory. This is our ‘object file’, hence the <code>.o</code>. This is
the binary code, in ELF format. Later, we’ll take this file and use it
to build our OS.</p>
<h2>Summary</h2>
<p>Congratulations! This is the first step towards building an operating system.
We learned about the boot process, the GRUB bootloader, and the Multiboot
specification. We wrote a Multiboot-compliant header file in assembly code, and
used <code>nasm</code> to create an object file from it.</p>
<p>Next, we’ll write the actual code that prints “Hello world” to the screen.</p>
<h1>Hello, world!</h1>
<p>Now that we’ve got the headers out of the way, let’s do the traditional first
program: Hello, world!</p>
<h2>The smallest kernel</h2>
<p>Our hello world will be just <em>20</em> lines of assembly code. Let’s begin.
Open a file called <code>boot.asm</code> and put this in it:</p>
<pre><code class="language-x86asm">start:
    hlt
</code></pre>
<p>You’ve seen the <code>name:</code> form before: it’s a <em>label</em>. This lets us name a line
of code. We’ll call this label <code>start</code>, which is the traditional name.
GRUB will use this convention to know where to begin.</p>
<p>The <code>hlt</code> statement is our first bit of ‘real’ assembly. So far, we had just
been declaring data. This is actual, executable code. It’s short for ‘halt’.
In other words, it ends the program.</p>
<p>By giving this line a label, we can call it, like a function. That’s what
GRUB does: “Call the function named <code>start</code>.” This function has just one
line: stop.</p>
<p>Unlike many other languages, you’ll notice that there’s no way to say if
this ‘function’ takes any arguments or not. We’ll talk more about that later.</p>
<p>This code won’t quite work on its own though. We need to do a little bit more
bookkeeping first. Here’s the next few lines:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    hlt
</code></pre>
<p>Three new bits of information. The first:</p>
<pre><code class="language-x86asm">global start
</code></pre>
<p>This says “I’m going to define a label <code>start</code>, and I want it to be available
outside of this file.” If we don’t say this, GRUB won’t know where to find its
definition. You can kind of think of it like a ‘public’ annotation in other
languages.</p>
<pre><code class="language-x86asm">section .text
</code></pre>
<p>We saw <code>section</code> briefly, but I told you we’d get to it later. The place where
we get to it is at the end of this chapter. For the moment, all you need to
know is this: code goes into a section named <code>.text</code>. Everything that comes
after the <code>section</code> line is in that section, until another <code>section</code> line.</p>
<pre><code class="language-x86asm">bits 32
</code></pre>
<p>GRUB will boot us into protected mode, aka 32-bit mode. So we have to specify
that directly. Our Hello World will only be in 32 bits. We’ll transition from
32-bit mode to 64-bit mode in the next chapter, but it’s a bit involved.
So let’s just stay in protected mode for now.</p>
<p>That’s it! We could theoretically stop here, but instead, let’s actually print
the “Hello world” text to the screen. We’ll start off with an ‘H’:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    hlt
</code></pre>
<p>This new line is the most complicated bit of assembly we’ve seen yet. There’s a
lot packed into this little line.</p>
<p>The first important bit is <code>mov</code>. This is short for <code>move</code>, and it sorta looks
like this:</p>
<pre><code class="language-text">mov size place, thing
</code></pre>
<p>Oh, <code>;</code> starts a comment, remember? So the <code>; H</code> is just for us. I put this
comment here because this line prints an <code>H</code> to the screen!</p>
<p>Yup, it does. Okay, so here’s why: <code>mov</code> copies <code>thing</code> into <code>place</code>. The amount
of stuff it copies is determined by <code>size</code>.</p>
<pre><code class="language-x86asm">;   size place      thing
;   |    |          |
;   V    V          V
mov word [0xb8000], 0x0248 ; H
</code></pre>
<p>“Copy one word: the number <code>0x248</code> to ... some place.</p>
<p>The place is a hexidecimal number, but has square brackets <code>[]</code> around it.
Those brackets are special. They mean “the address in memory located by this
number.” In other words, we’re copying the number <code>0x0248</code> into the specific
memory location <code>0xb8000</code>. That’s what this line does.</p>
<p>Why? Well, we’re using the screen as a “memory mapped” device. Specific
positions in memory correspond to certain positions on the screen. And
the position <code>0xb8000</code> is one of those positions: the upper-left corner of the
screen.</p>
<p>Now, we are copying <code>0x0248</code>. Why this number? Well, it’s in three parts:</p>
<pre><code class="language-text"> __ background color
/  __foreground color
| /
V V  
0 2 48 &lt;- letter, in ASCII
</code></pre>
<p>We’ll start at the right. First, two numbers are the letter, in ASCII. <code>H</code> is
72 in ASCII, and 48 is 72 in hexidecimal: <code>(4 * 16) + 8 = 72</code>. So this will
write <code>H</code>.</p>
<p>The other two numbers are colors. There are 16 colors available, each with a
number. Here’s the table:</p>
<pre><code>| Value | Color          |
|-------|----------------|
| 0x0   | black          |
| 0x1   | blue           |
| 0x2   | green          |
| 0x3   | cyan           |
| 0x4   | red            |
| 0x5   | magenta        |
| 0x6   | brown          |
| 0x7   | gray           |
| 0x8   | dark gray      |
| 0x9   | bright blue    |
| 0xA   | bright green   |
| 0xB   | bright cyan    |
| 0xC   | bright red     |
| 0xD   | bright magenta |
| 0xE   | yellow         |
| 0xF   | white          |
</code></pre>
<p>So, <code>02</code> is a black background with a green foreground. Classic. Feel free to
change this up, use whatever combination of colors you want!</p>
<p>So this gives us a <code>H</code> in green, over black. Next letter: <code>e</code>.</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    hlt
</code></pre>
<p>Lower case <code>e</code> is <code>65</code> in ASCII, at least, in hexidecimal. And <code>02</code> is our same
color code. But you’ll notice that the memory location is different.</p>
<p>Okay, so we copied four hexidecimal digits into memory, right? For our <code>H</code>.
<code>0248</code>. A hexidecimal digit has sixteen values, so two of them are 32. Since we
need one word for the colors, and one word for the <code>H</code>, that’s two words.
Hence, if our first memory position is at <code>0</code>, the second letter will start at
<code>2</code>.</p>
<p>This math gets easier the more often you do it. And we won’t be doing <em>that</em> much
more of it. There is a lot of working with hex numbers in operating systems work,
so you’ll get better as we practice.</p>
<p>With this, you should be able to get the rest of Hello, World. Go ahead and try
if you want: each letter needs to bump the location twice, and you need to look
up the letter’s number in hex.</p>
<p>If you don’t want to bother with all that, here’s the final code:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    mov word [0xb8004], 0x026c ; l
    mov word [0xb8006], 0x026c ; l
    mov word [0xb8008], 0x026f ; o
    mov word [0xb800a], 0x022c ; ,
    mov word [0xb800c], 0x0220 ; 
    mov word [0xb800e], 0x0277 ; w
    mov word [0xb8010], 0x026f ; o
    mov word [0xb8012], 0x0272 ; r
    mov word [0xb8014], 0x026c ; l
    mov word [0xb8016], 0x0264 ; d
    mov word [0xb8018], 0x0221 ; !
    hlt
</code></pre>
<p>Finally, now that we’ve got all of the code working, we can assemble our
<code>boot.asm</code> file with <code>nasm</code>, just like we did with the <code>multiboot_header.asm</code>
file:</p>
<pre><code class="language-bash">$ nasm -f elf64 boot.asm
</code></pre>
<p>This will produce a <code>boot.o</code> file. We’re almost ready to go!</p>
<h2>Linking it together</h2>
<p>Okay! So we have two different <code>.o</code> files: <code>multiboot_header.o</code> and <code>boot.o</code>.
But what we need is <em>one</em> file with both of them. Our OS doesn’t have the
ability to do anything yet, let alone load itself in two parts somehow. We just
want one big binary file.</p>
<p>Enter ‘linking’. If you haven’t worked in a compiled language before, you
probably haven’t had to deal with linking before. Linking is how we’ll turn
these two files into a single output: by linking them together.</p>
<p>Open up a file called <code>linker.ld</code>and put this in it:</p>
<pre><code class="language-text">ENTRY(start)

SECTIONS {
    . = 1M;

    .boot :
    {
        /* ensure that the multiboot header is at the beginning */
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }
}
</code></pre>
<p>This is a ‘linker script’. It controls how our linker will combine these
files into the final output. Let’s take it bit-by-bit:</p>
<pre><code class="language-text">ENTRY(start)
</code></pre>
<p>This sets the ‘entry point’ for this executable. In our case, we called our
entry point by the name people use: <code>start</code>. Remember? In <code>boot.s</code>? Same
name here.</p>
<pre><code class="language-text">SECTIONS {
</code></pre>
<p>Okay! I’ve been promising you that we’d talk about sections. Everything inside
of these curly braces is a section. We annotated parts of our code with
sections earlier, and here, in this part of the linker script, we will describe
each section by name and where it goes in the resulting output.</p>
<pre><code class="language-text">    . = 1M;
</code></pre>
<p>This line means that we will start putting sections at the one megabyte mark.
This is the conventional place to put a kernel, at least to start. Below one
megabyte is all kinds of memory-mapped stuff. Remember the VGA stuff? It
wouldn’t work if we mapped our kernel’s code to that part of memory... garbage
on the screen!</p>
<pre><code class="language-text">    .boot :
</code></pre>
<p>This will create a section named <code>boot</code>. And inside of it...</p>
<pre><code class="language-text">        *(.multiboot_header)
</code></pre>
<p>... goes every section named <code>multiboot_header</code>. Remember how we defined that
section in <code>multiboot_header.asm</code>? It’ll be here, at the start of the <code>boot</code>
section. That’s what we need for GRUB to see it.</p>
<pre><code class="language-text">    .text :
</code></pre>
<p>Next, we define a <code>text</code> section. The <code>text</code> section is where you put code.
And inside of it...</p>
<pre><code class="language-text">        *(.text)
</code></pre>
<p>... goes every section named <code>.text</code>. See how this is working? The syntax is a
bit weird, but it’s not too bad.</p>
<p>That’s it for our script! We can then use <code>ld</code> to link all of this stuff
together:</p>
<pre><code class="language-bash">$ ld --nmagic --output=kernel.bin --script=linker.ld multiboot_header.o boot.o
</code></pre>
<p>By running this command, we do a few things:</p>
<pre><code class="language-text">--nmagic
</code></pre>
<p>TODO: https://github.com/intermezzOS/book/issues/30</p>
<pre><code class="language-text">--output=kernel.bin
</code></pre>
<p>This sets the name of our output file. In our case, that’s <code>kernel.bin</code>. We’ll be using
this file in the next step. It’s our whole kernel!</p>
<pre><code class="language-text">--script=linker.ld
</code></pre>
<p>This is the linker script we just made.</p>
<pre><code class="language-text">multiboot_header.o boot.o
</code></pre>
<p>Finally, we pass all the <code>.o</code> files we want to link together.</p>
<p>That’s it! We’ve now got our kernel in the <code>kernel.bin</code> file. Next, we’re going to
make an ISO out of it, so that we can load it up in QEMU.</p>
<h1>Making an ISO</h1>
<p>Now that we have our <code>kernel.bin</code>, the next step is to make an ISO. Remember
compact discs? Well, by making an ISO file, we can both test our Hello World
kernel in QEMU, as well as running it on actual hardware!</p>
<p>To do this, we’re going to use a GRUB tool called <code>grub-mkrescue</code>. We have to
create a certain structure of files on disk, run the tool, and we’ll get an
<code>os.iso</code> file at the end.</p>
<p>Doing so is not very much work, but we need to make the files in the right
places. First, we need to make three directories:</p>
<pre><code class="language-bash">$ mkdir -p isofiles/boot/grub
</code></pre>
<p>The <code>-p</code> flag to <code>mkdir</code> will make the directory we specify, as well as any
‘parent’ directories, hence the <code>p</code>. In other words, this will make an
<code>isofiles</code> directory, with a <code>boot</code> directory inside, and a <code>grub</code> directory
inside of that.</p>
<p>Next, create a <code>grub.cfg</code> file inside of that <code>isofiles/boot/grub</code> directory,
and put this in it:</p>
<pre><code class="language-text">set timeout=0
set default=0

menuentry &quot;intermezzOS&quot; {
    multiboot2 /boot/kernel.bin
    boot
}
</code></pre>
<p>This file configures GRUB. Let’s talk about the <code>menuentry</code> block first.
GRUB lets us load up multiple different operating systems, if we desire. Each
<code>menuentry</code> section corresponds to one of these. We give it a name, in this
case, <code>intermezzOS</code>, and then a little script to tell it what to do. First,
we use the <code>multiboot2</code> command to point at our kernel file. In this case,
that location is <code>/boot/kernel.bin</code>. Remember how we made a <code>boot</code> directory
inside of <code>isofiles</code>? Since we’re making the ISO out of the <code>isofiles</code> directory,
everything inside of it is at the root of our ISO. Hence <code>/boot</code>.</p>
<p>Let’s copy our <code>kernel.bin</code> file there now:</p>
<pre><code class="language-bash">$ cp kernel.bin isofiles/boot/
</code></pre>
<p>Finally, the <code>boot</code> command says “that’s all the configuration we need to do,
boot it up.</p>
<p>But what about those <code>timeout</code> and <code>default</code> settings? Well, the <code>default</code> setting
controls which <code>menuentry</code> we want to be the default. The numbers start at zero,
and since we only have that one, we set it as the default. When GRUB starts, it
will wait for <code>timeout</code> seconds, and then choose the <code>default</code> option if the user
didn’t pick a different one. Since we only have one option here, we just set it to
zero, so it will start up right away.</p>
<p>The final layout should look like this:</p>
<pre><code class="language-text">isofiles/
└── boot
    ├── grub
    │   └── grub.cfg
    └── kernel.bin
</code></pre>
<p>Using <code>grub-mkrescue</code> is easy. We run this command:</p>
<pre><code class="language-bash">$ grub-mkrescue -o os.iso isofiles
</code></pre>
<p>The <code>-o</code> flag controls the <em>o</em>utput filename, which we choose to be <code>os.iso</code>.
And then we pass it the directory to make the ISO out of, which is the
<code>isofiles</code> directory we just set up.</p>
<p>After this, you have an <code>os.iso</code> file with our teeny kernel on it. You could
burn this to a USB stick or CD and run it on an actual computer if you wanted
to! But doing so would be really annoying during development. So in the next
setction, we’ll use an emulator, QEMU, to run the ISO file on our development
machine.</p>
<h1>Running in QEMU</h1>
<p>Let’s actually run our kernel! To do this, we’ll use QEMU, an emulator. Using
QEMU is fairly straightfoward:</p>
<pre><code class="language-bash">$ qemu-system-x86_64 -cdrom os.iso
</code></pre>
<p>Type it in, hit enter, and you should see Hello World!</p>
<p><img alt="hello world" class="center" src="assets/hello_world.png" /></p>
<p>If it shows up for you too, congrats! If not, something may have gone
wrong. Double check that you followed the examples <em>exactly</em>. Maybe
you missed something, or made a mistake while copying things down.</p>
<p>Note all of this other stuff behind the Hello World message: We didn’t
clear the screen, so everything from GRUB just stays as it is. We’ll
write a function to do that eventually...</p>
<p>Let’s talk about this command before we move on:</p>
<pre><code class="language-text">qemu-system-x86_64
</code></pre>
<p>We’re running the <code>x86_64</code> varient of QEMU. While we have a 32-bit kernel for
now, soon we’ll have a 64-bit one. And since things are backwards compatible,
this works just fine.</p>
<pre><code class="language-text">-cdrom os.iso
</code></pre>
<p>We’re going to start QEMU with a CD-ROM drive, and its contents are the
<code>os.iso</code> file we made.</p>
<p>That’s it! Here’s the thing, though: while that wasn’t <em>too</em> complicated, it
was a lot of steps. Each time we make a change, we have to go through all these
steps over again. In the next section, we’ll use Make to do all these steps for
us.</p>
<h1>Automation with Make</h1>
<p>(Author’s note: I wrote this post sort of backwards-first, but I’m done
writing for the night, so I’m pushing this up as an extra-rough draft.</p>
<p>I will explain all of this soon, but until I write it down, you can put
all of this in a file called <code>Makefile</code>.)</p>
<pre><code class="language-make">default: run

.PHONY: clean

multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o

isofiles: kernel.bin grub.cfg
        mkdir -p isofiles/boot/grub
        cp grub.cfg isofiles/boot/grub
        cp kernel.bin isofiles/boot/

os.iso: isofiles
        grub-mkrescue -o os.iso isofiles

build: os.iso

run: os.iso
        qemu-system-x86_64 -cdrom os.iso

clean: 
        rm -f multiboot_header.o
        rm -f boot.o
        rm -f kernel.bin
        rm -rf isofiles
        rm -f os.iso
</code></pre>
<p>You'll notice that there is a fair amount of repetition here. At first, that's
pretty okay: make can be a bit hard to understand, and while it has features
that let you de-duplicate things, they can also get unreadable really fast.</p>
<h2>Creating a build subdirectory</h2>
<p>Here's one example of a tweak we can do: <code>nasm</code> supports a <code>-o</code> flag, which
controls the name of the output file. We can use this to build <em>everything</em> in
a <code>build</code> subdirectory. This is nice for a number of reasons, but one of the
simplest is that all of our generated files will go in a single directory,
which means that it’s much easier to keep track of them: they’ll all be in one
place.</p>
<p>Let’s make some changes: More specifically, three of them:</p>
<pre><code class="language-make">build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o
</code></pre>
<p>The first one is the name of the rule. We have to add a <code>build/</code> in front of
the filename. This is because we’re going to be putting this file in that
directory now.</p>
<p>Second, we added another line: <code>mkdir</code>. We used <code>-p</code> to make directories
before, but in this case, the purpose of the flag is to not throw an error
if the directory already exists. We need to try to make this directory
when we build so that we can put our <code>.o</code> file in it!</p>
<p>Finally, we add the <code>-o</code> flag to <code>nasm</code>. This will create our output file in
that <code>build</code> directory, rather than in the current one.</p>
<p>With that, we’re ready to modify <code>boot.o</code> as well:</p>
<pre><code class="language-make">build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o
</code></pre>
<p>These changes are the same, just with <code>boot</code> instead of <code>multiboot_header</code>.</p>
<p>Next up: <code>kernel.bin</code>:</p>
<pre><code class="language-make">build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o
</code></pre>
<p>We append <code>build</code> in no fewer than <em>six</em> places. Whew! At least it’s
straightforward.</p>
<pre><code class="language-make">build/isofiles: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/
</code></pre>
<p>In a similar fashion, we prefix all the things with <code>build</code>.</p>
<pre><code class="language-make">build/os.iso: build/isofiles
        grub-mkrescue -o build/os.iso build/isofiles
</code></pre>
<p>Seeing a pattern yet? More prefixing.</p>
<pre><code class="language-make">run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso
</code></pre>
<p>... and here as well.</p>
<pre><code class="language-make">clean: 
        rm -rf build
</code></pre>
<p>Now some payoff! To get rid of our generated files, all we have to do is <code>rm</code>
our <code>build</code> directory. Much easier.</p>
<p>Here’s our final version:</p>
<pre><code class="language-make">default: run

.PHONY: clean

build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o

build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o

build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o

build/isofiles: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/

build/os.iso: build/isofiles
        grub-mkrescue -o build/os.iso build/isofiles

run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso

clean: 
        rm -rf build
</code></pre>
<p>We can go farther, and eventually, we will. But this is good enough for now.
Like I said, there’s a fine balance between keeping it DRY and making it
non-understandable.</p>
<p>Luckily, we’ll only be using Make for these assembly files. Rust has its own
build tool, Cargo, that we’ll integrate with Make. It’s a lot easier to use.</p>
<h1>Source Control with Git</h1>
<h1>Transitioning to Long Mode</h1>
<h1>A Rust kmain()</h1>
<h1>A simple VGA driver</h1>
<h1>Keyboard input</h1>
<p>COMING SOON</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
