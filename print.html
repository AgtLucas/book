<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="what.html"><strong>1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong>1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong>1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong>1.4.</strong> What tools will we use?</a></li></ul></li><li><a href="setup.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="osx.html"><strong>2.2.</strong> Mac OS X</a></li><li><a href="windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="booting-up.html"><strong>3.</strong> Booting up</a></li><li><ul class="section"><li><a href="multiboot-headers.html"><strong>3.1.</strong> Multiboot headers</a></li><li><a href="hello-world.html"><strong>3.2.</strong> Hello, world!</a></li><li><a href="making-an-iso.html"><strong>3.3.</strong> Making an ISO</a></li><li><a href="running-in-qemu.html"><strong>3.4.</strong> Running in QEMU</a></li><li><a href="automation-with-make.html"><strong>3.5.</strong> Automation with Make</a></li><li><a href="source-control-with-git.html"><strong>3.6.</strong> Source Control with Git</a></li></ul></li><li><a href="transitioning-to-long-mode.html"><strong>4.</strong> Transitioning to Long Mode</a></li><li><a href="a-rust-kmain.html"><strong>5.</strong> A Rust kmain()</a></li><li><a href="simple-vga.html"><strong>6.</strong> A simple VGA driver</a></li><li><a href="keyboard-input.html"><strong>7.</strong> Keyboard input</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">intermezzOS</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1 class="center">intermezzOS</h1>
<p><img class="center" src="rhizome.jpg" alt="rhizome" /></p>
<p class="center">An operating system for learning</p>
<h2>Preface</h2>
<p>This book describes the intermezzOS project. intermezzOS is a hobby operating
system, specifically targeted at showing beginners how to get into operating
systems development. Rather than describe some sort of final OS, it instead
proceeds in a tutorial-like fashion, allowing you to implement intermezzOS
yourself, alongside the book.</p>
<p>The book assumes that you have programmed in some language before, but not any
particular one. In fact, people who have not done low-level programming before
are a specific target of this book; I’ll be explaining a lot of things that
other resources will just assume that you know.</p>
<p>intermezzOS is implemented in <a href="https://www.rust-lang.org/">Rust</a>, and some
assembly code. We’ll try to explain Rust along the way, but may refer you to
its documentation when things get tricky. This book isn’t <em>really</em> about
learning Rust, but you might accidentally along the way.</p>
<p>You can find all of this stuff <a href="https://github.com/intermezzOS/">on GitHub</a>.
This book is in the <code>book</code> repository, the kernel is in <code>kernel</code>, and the
website is there, too. Feel free to open issues on the <a href="https://github.com/intermezzOS/rfcs">RFCs
repo</a> if you want to discuss things
in a general sense, and send bug reports and PRs to the appropriate repos
if you’d like to help with a particular component.</p>
<h2>The Story</h2>
<p>A long time ago, in college, my friends and I were working on a hobby operating
system, <a href="http://xomb.org">XOmB</a>. It was... tough. Frankly, while I learned a
lot, I was a pretty minor contributor. I got frustrated too easily. One day, I
found Ruby, and I was pretty much done with low-level programming. I had done
it most of my life, and I was bored. Bored, and sick of dealing with core
dumps.</p>
<p>Those details aren’t that important. What is important is that over the years,
I’ve always wanted to get back into this stuff. But the problem is this: there
are a lot of people who do hobby operating system work, but... I don’t like
their attitudes.</p>
<p>You see, a lot of people see low-level programming as some kind of superior,
only-for-the-smartest kind of thing. They have a puritanical world-view: I
suffered to learn this, so you too must suffer, to build character. I think
that’s short sighted. Low level programming <em>is</em> difficult to get into, but
that says more about the teachers’ faults than the students’.</p>
<p>Anyway, as my professional life has moved back towards the low level, I’ve been
thinking about this topic a lot again. That’s when I found an awesome link:
<a href="http://os.phil-opp.com/multiboot-kernel.html">Writing an OS in Rust by Philipp Oppermann</a>. I cannot speak enough
about how awesome Phil’s tutorial is; it single-handedly inspired me to get
back into operating systems.</p>
<p>The big difference with Phil’s tutorial is that it doesn’t treat you as being
stupid for not knowing ‘the basics’. It doesn’t say “spend hours debugging this
thing, because I did.” It doesn’t insult you for being new. It just explains
the basics of a kernel.</p>
<p>It’s amazing how much a little bit of a framing can completely change the way
you see something. When the examples I found were all about how you have to be
an amazing rockstar ninja and we won’t give you all the code because you suck
if you can’t figure it out, I hated this stuff. When it was kind,
understanding, and helpful, I couldn’t get enough.</p>
<p>Once I got to a certain part in Phil’s tutorial, I started implementing stuff
myself. A lot of the initial code here is going to be similar to Phil’s.
But I’m going to write about it anyway. There’s a good reason for that:</p>
<blockquote>
<p>Writing is nature’s way of showing us how sloppy our thinking is.</p>
<ul>
<li>Leslie Lamport</li>
</ul>
</blockquote>
<p>By re-explaining things in my own words, I hope to understand it even better.
This is just a perpetual theme with me: I like teaching because it helps me
learn. I like writing because it helps me understand.</p>
<p>The first section of the book is going to be clear about where we’re following
Phil, and where we break off and go into our own little world. After the start,
things will end up diverging.</p>
<p>Furthermore, I will not commit to any kind of schedule for this project. It’s
going to be in my spare time, and I’m learning a lot of this as I go, too.</p>
<h2>The Name</h2>
<blockquote>
<p>The nomad has a territory; he follows customary paths; he goes from one point
to another; he is not ignorant of points (water points, dwelling points,
assembly points, etc.). But the question is what in nomad life is a principle
and what is only a consequence. To begin with, although the points determine
paths, they are strictly subordinated to the paths they determine, the
reverse happens with the sedentary. The water point is reached only in order
to be left behind; every point is a relay and exists only as a relay. A path
is always between two points, but the in-between has taken on all the
consistency and enjoys both an autonomy and a direction of its own. The life
of the nomad is the intermezzo.</p>
<p>Deleuze and Guattari, “A Thousand Plateaus”, p380</p>
</blockquote>
<p>If you’re not into particular kinds of philosophy, this quote won’t mean a lot.
Let’s look at the dictionary definition:</p>
<blockquote>
<p>An intermezzo, in the most general sense, is a composition which fits between
other musical or dramatic entities, such as acts of a play or movements of a
larger musical work.</p>
<p><a href="https://en.wikipedia.org/wiki/Intermezzo">https://en.wikipedia.org/wiki/Intermezzo</a></p>
</blockquote>
<p>I want this project to be about learning. Learning is often referred to as a
journey. You start off in ignorance, and end in knowledge. In other words,
‘learning’ is that part in the middle, the in-between state.</p>
<p>The tricky thing about learning is, you never stop learning. Once you learn
something, there’s something new to learn, and you’re on a journey again.</p>
<p>If you want to learn a lot, then you’ll find yourself perpetually in the
middle.</p>
<p>There is another sense by which this name makes sense: as we’ll learn in the
beginning of the book, operating systems are largely about abstractions. And
abstractions are themselves ‘in the middle’, between what they’re abstracting
and who they are abstracting it for.</p>
<h2>Principles</h2>
<p>Here are the guiding principles of intermezzOS:</p>
<ul>
<li>We’re all actual people. Please treat each other as such.</li>
<li>We’re all here to learn. Let’s help each other learn, rather than being some
kind of vanguard of knowledge.</li>
<li>The only thing that matters about your language background is the amount you
may have to learn.</li>
<li>Everything must be documented, or it’s not done.</li>
</ul>
<p>And of course, everything related to this project is under the <a href="http://intermezzos.github.io/code-of-conduct.html">Code of
Conduct</a>.</p>
<h1>Background</h1>
<p>Before we get going, we should probably have some idea of where we’re headed.</p>
<h1>What is an OS?</h1>
<p>It’s actually kind of difficult to define what an operating system is. There
are a lot of different kinds of operating systems, and they all do different
kinds of things.</p>
<p>There are some shared goals, however. Let’s try this out as a working
definition:</p>
<blockquote>
<p>An operating system is a program that provides a platform for other
programs. It provides two things to these programs: abstractions and
isolation.</p>
</blockquote>
<p>This is good enough for now. Let’s consider this a test for inclusion,
but not exclusion. In other words, things that fit this definition
<em>are</em> operating systems, but things that don’t may or may not be,
we don’t quite know.</p>
<h2>Creating abstractions</h2>
<p>There are many reasons to create a platform for other programs, but a
common one for operating systems is to abstract over hardware.</p>
<p>Consider a program, running on some hardware:</p>
<p><img alt="program on hardware" class="center" src="assets/program_hardware.png" /></p>
<p>This program will need to know <em>exactly</em> about what kind of hardware exists.
If you want to run it on a different computer, it will have to know exactly
about that computer too. And if you want to write a second program, you’ll
have to re-write all of that code.</p>
<blockquote>
<p>All problems in computer science can be solved by another level of
indirection.</p>
<ul>
<li>David Wheeler</li>
</ul>
</blockquote>
<p>To solve this problem, we can introduce an abstraction:</p>
<p><img alt="program on os on hardware" class="center" src="assets/program_os_hardware.png" /></p>
<p>Now, the operating system can handle the details of the hardware, and provide
an API for it. A program can be written for that operating system’s API, and
can then run on any hardware that the operating system supports.</p>
<p>At some point, though, we developed many operating systems. Since operating
systems are platforms, most people pick one and have only that one on their
computer. So now we have a problem that looks the same, but is a bit
different: our program is now specific to an OS, rather than specific to
a particular bit of hardware.</p>
<p>To solve this, some programming languages have a ‘virtual machine.’ This
was a big selling point of Java, for example: the Java Virtual Machine.
The idea here is that we create a <em>virtual</em> machine on top of the <em>real</em>
machine.</p>
<p><img alt="program on vm " class="center" src="assets/program_vm_os_hardware.png" /></p>
<p>Now, you write programs for the Java Virtual Machine, which is then ported
to each operating system, which is then ported to all the hardware. Whew!</p>
<p>This, of course, leads to the collary to the previous maxim:</p>
<blockquote>
<p>...except for the problem of too many layers of indirection.</p>
<ul>
<li>Kevlin Henney</li>
</ul>
</blockquote>
<p>We now have a pattern:</p>
<ul>
<li>I have <code>A</code>.</li>
<li><code>A</code> is written explicitly for <code>X</code>...</li>
<li>... but I want to support <code>X</code> and <code>Y</code>,</li>
<li>so I put abstraction <code>B</code> in the middle.</li>
</ul>
<p>We will see this pattern over and over again. Hence ‘intermezzo’: abstractions
are always in the middle.</p>
<h2>Isolation</h2>
<p>Many of the abstractions provided are, as we discussed, abstractions over
hardware. And hardware often has a pretty serious restriction: only one
program can access the hardware at a time. So if our operating system is going
to be able to run multiple programs, which is a common feature of many
operating systems, we’ll also need to make sure that multiple programs cannot
access hardware at the same time.</p>
<p>This really applies to more than just hardware though: once we have two
programs, it would not be ideal to let them mess with each other. Consider any
sort of program that deals with your password: if programs could mess with each
other’s memory and code, then a program could trivially steal your password
from another program!</p>
<p>This is just one symptom of a general problem. It’s much better to isolate
programs from each other, for a number of different reasons. For now, we’ll
just consider isolation as one of our important jobs, as OS authors.</p>
<h3>Wait a minute...</h3>
<p>Here’s a question for you to ponder: if we didn’t provide isolation, isn’t that
just a poor abstraction? In other words, if we had an abstraction where we
could interact with other things being abstracted... isn’t that just a bad job
of doing the abstraction? And in that sense, is the only thing an operating
system does abstraction? Is the only thing everything does abstraction?</p>
<p>I don’t have answers for you. If you figure it out, let me know...</p>
<h1>What kinds of OS are there?</h1>
<p>Okay, so here’s the thing: operating systems are made up of a <em>lot</em> of
components. The core component is called a ‘kernel’. So, as OS developers, when
we categorize operating systems, we tend to categorize them by what kinds of
kernel they have. At the start, our ‘operating system’ will be just the kernel,
and so we’ll tend to focus on kernels for the first part of our journey.</p>
<p>The non-kernel bits of an operating system are called a ‘userland’. It’s where
the users live. This is also while you’ll hear some people say, “It’s
GNU/Linux, not Linux.” That’s because virtually all Linux distributions today
use a Linux kernel + a GNU userland. So the GNU folks are a bit annoyed that
the kernel gets all the credit. By the same token, a lot of people say ‘the
kernel’ when they mean ‘the Linux kernel.’ This gets an entirely different set
of people mad.</p>
<p>Sometimes, it just seems like everything makes everyone mad.</p>
<p>Anyway...</p>
<p>The way that we categorize different kernels largely comes down to “what is in
the kernel and what is in userspace.” Upon reading this, you might then think
the easiest kind of kernel to write is the smallest, where everything is in
userspace. After all, smaller should be easier, right? Well... that’s not
actually true. Or at least, it’s not clear that it’s true.</p>
<h2>Monolithic kernels</h2>
<p>First, we have ‘monolithic kernels’. ‘Mono’ meaning ‘one’. One big ‘ol kernel.
Most real-world kernels are monolithic kernels, or at least, pretend to be.
Don’t worry about it. Linux, for example, is a monolithic kernel.</p>
<p>This means that monolithic kernels are kind of ‘the default’. Other kernels
usually define themselves by solving some kind of problem that monolithic
kernels have.</p>
<p>If a monolithic kernel were a web application, it would be a big ‘ol Rails
application. One repository. A million subdirectories. It may be a big ball
of mud, but it pays the bills.</p>
<h2>Microkernels</h2>
<p>Microkernels are, well, micro. Smaller. A lot of the functionality that’s in
the kernel is in userspace instead. This is a good idea in theory, but
historically, microkernels have had issues. All that communication has
overhead, which makes them slower.</p>
<p>Mach, the kernel that Mac OS X uses, is a microkernel. Well, sort of. It ended
up being one, but Mac OS X uses a version of Mach from before that work was
done... so it’s a bit blurry.</p>
<p>If a microkernel were a web application, it would be a microservice. And a
bunch of the other stuff that’s in kernel space in a monolithic kernel are
other microservices, but in userspace instead. It’s a bit cooler than a single
monolithic web app by itself, and the communication is nice for flexibility’s
sake, but has some overhead.</p>
<h2>Exokernels &amp; Unikernels</h2>
<p>These two kinds of operating systems are closely related, but it’s a bit harder
to dig into what exactly makes them different. Unikernels have one
easy-to-describe feature: they only run one single program at a time.
Exokernels are ‘more micro than micro’, but the details aren’t important right
now.</p>
<p>The important thing to know here is that there are a lot of other kinds of
designs than just monolithic vs. micro. There’s a lot of stuff to learn!</p>
<h1>What kind are we making?</h1>
<p>So, given all these kinds of operating systems, what kind are we making?</p>
<p>The answer is “it doesn’t even matter at first.” There’s some commonality in
almost all of these styles of operating systems, and we have to get all that
done before we even make those decisions.</p>
<p>Secondly, we could waste a <em>lot</em> of time trying to design our perfect OS. And
then never actually build it. Remember, the goal here is <em>to learn</em>, not <em>to
make the best OS that ever existed</em>. So really, what it ends up looking like
just doesn’t really matter at all. Most hobby operating system projects die
quite young.</p>
<p>Let’s focus on the <em>doing</em>, and the less on the categorization, planning, and
being. A nice thing about operating systems is that there’s a lot of freedom of
direction. To tie it back into the example earlier, Phil’s tutorial starts
going into memory-management after getting printing to the screen going. We’ll
be going into keyboards first instead. There are, of course, some dependencies,
but there’s also a lot of freedom.</p>
<h1>What tools will we use?</h1>
<p>Before we can make a kernel, we need to figure out the tools we’re going to
use. The first question, of course, is what programming language?</p>
<p>In our case, we’re going to use two. The first one is the language that
<em>every</em> kernel must use: assembly language.</p>
<h2>Assembly</h2>
<p>Assembly language looks like this:</p>
<pre><code class="language-x86asm">section .data
global _start

_start:
    mov rax, 0
loop:
    add rax, 1
    cmp rax, 10
    jne loop

    mov rbx, rax
    mov rax, 1
    int 80h
</code></pre>
<p>This is a little program in assembly language. We can run it like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 lol.asm # assemble into lol.o
$ ld lol.o              # link into a.out
$ ./a.out               # run it
$ echo $?               # print out the exit code
10
$
</code></pre>
<p>You can write entire kernels in assembly if you want to. It’s not as bad as it
may sound. At the very beginning, we will <em>have</em> to use assembly. But not very
much. It takes about 100 lines total, to start. Completely manageable.</p>
<h2>Rust</h2>
<p>We will augment our assembly with code written in
<a href="https://www.rust-lang.org/">Rust</a>. In fact, we will be trying to get to
Rust-land as quickly as we possibly can. Rust is a really great programming
language, and it’s pretty great for writing operating systems. It has some
rough edges, but they’re not too big of a deal.</p>
<p>Rust will allow us to write:</p>
<pre><code class="language-rust">use std::process;

fn main() {
    let mut a = 0;

    for _ in 0..10 {
        a = a + 1;
    }

    process::exit(a);
}
</code></pre>
<p>This does the same thing as our assembly code:</p>
<pre><code class="language-bash">$ rustc lol.rs # compile our Rust code to lol
$ ./lol        # run it
$ echo $?      # print out the exit code
10
$
</code></pre>
<p>That Rust code probably looks more like a programming language you’ve used in
the past. It’s a lot nicer to write complex things in a higher-level
programming language like Rust. That said, virtually all languages are
higher-level than assembly, so that’s not saying all that much. Rust is still a
low-level language by many standards.</p>
<p>So why choose Rust? Well, I’m picking it for two reasons:</p>
<ol>
<li>I love it.</li>
<li>There aren’t a lot of kernels in it yet.</li>
</ol>
<p>There are a suprising number of people working on kernels in Rust. But since
it’s a newer language, there aren’t nearly as many as for older, more
established languages.</p>
<h2>Do I need to be a wizard?</h2>
<p>No, you do not. A common theme of this project is “this is all we’ll need to
know about this topic for now.” There’s no reason that you need to absolutely
master everything before going forward. For example, in order to get Rust
going, we need only about 100 lines of assembly, as mentioned above. Do you
need to be a complete expert in assembly language to understand those well
enough to keep going? Not at all. Will learning more about it help? Absolutely!</p>
<p>There’s nobody that’s monitoring your credentials to see if you’re allowed to
move on. Do it at your own pace. Skip stuff. Come back when you don’t
understand what’s going on. Try it, wait a week, and then try it again.</p>
<p>There’s no wrong way to do this stuff, including by being a beginner. Everyone
was once. Don’t let anyone discourage you.</p>
<h1>Setting up a development environment</h1>
<p>Frankly, one of the hardest parts of starting an operating system is getting a
development environment going. Normally, you’re doing work on the same
operating system you’re developing for, and we don’t have that luxury. Yet!</p>
<p>There is a convention called a ‘target triple’ to describe a particular
platform. It’s a ‘triple’ because it has three parts:</p>
<pre><code class="language-text">arch-kernel-userland
</code></pre>
<p>So, a target triple for a computer which has an x86-64 bit processor running a
Linux kernel and the GNU userland would look like this:</p>
<pre><code class="language-text">x86_64-linux-gnu
</code></pre>
<p>However, it can also be useful to know the operating system as well, and so
the ‘triple’ part can be extended to include it:</p>
<pre><code class="language-text">x86_64-unknown-linux-gnu
</code></pre>
<p>This is for some unknown Linux. If we were targeting Debian specifically, it
would be:</p>
<pre><code class="language-text">x86_64-debian-linux-gnu
</code></pre>
<p>Since it’s four parts, it’s called a ‘target’ rather than a ‘target triple’,
but you’ll still hear some people call it a triple anyway.</p>
<p>Kernels themselves don’t need to be for a specific kernel, and so you’ll
see ‘none’ get used:</p>
<pre><code class="language-text">x86_64-unknown-none
</code></pre>
<h2>Hosts &amp; Targets</h2>
<p>The reason that they’re called a ‘target’ is that it’s the architecture you’re
compiling <em>to</em>. The architecture you’re compiling <em>from</em> is called the ‘host
architecture’.</p>
<p>If the target and the host are the same, we call it ‘compiling’. If they are
different, we call it ‘cross-compiling’. So you’ll see people say things like</p>
<blockquote>
<p>I cross-compiled from x86_64-linux-gnu to x86-unknown-none.</p>
</blockquote>
<p>This means that the computer that the developer was using was a 64-bit
GNU/Linux machine, but the final binary was for a 32-bit x86 machine with no
OS.</p>
<p>So we need a slightly special environment to build our OS: we need to
cross-compile from whatever kind of computer we are using to our new target.</p>
<h2>Cheat codes</h2>
<p>... but we can also cheat. It’s okay to cheat. Well, in this case, it’s really
only okay at the start. We’ll eventually <em>have</em> to cross-compile, or things
will go wrong.</p>
<p>Here’s the cheat: if you are developing on an x86_64 Linux machine, and you’re
not using any special Linux kernel features, then the difference between
<code>x86_64-linux-gnu</code> and <code>x86_64-unknown-none</code> is really just theoretical. It
will still technically <em>work</em>. For now.</p>
<p>This is a common pitfall with new operating system developers. They’ll start
off with the cheat, and it will come back to haunt them later. Don’t worry;
I will actually show you how to fix things before they go wrong. Knowing the
difference here is still useful.</p>
<h1>Linux</h1>
<p>Here are the tools we’re going to need:</p>
<ul>
<li>Rust</li>
<li><code>nasm</code></li>
<li><code>ld</code></li>
<li><code>grub-mkrescue</code> + <code>xorriso</code></li>
<li><code>qemu</code></li>
</ul>
<p>To install Rust, check out <a href="https://github.com/brson/multirust">multirust</a>.</p>
<p>Once you have it installed, grab a nightly build:</p>
<pre><code class="language-bash">$ multirust update PUT NIGHTLY HERE
$ multirust default PUT NIGHTLY HERE
</code></pre>
<p>To install the other tools, on Debian:</p>
<pre><code class="language-bash">$ sudo apt-get install nasm xorriso qemu
</code></pre>
<h1>Mac OS X</h1>
<p>For now, the easiest way to get going is to install Linux on a virtual
machine, and follow the Linux instructions.</p>
<p>I hope to have better instructions for OS X soon; since I don’t have a
computer that runs it, I need to figure it out first. If you know how,
this would be a great way to <a href="https://github.com/intermezzOS/book">contribute</a></p>
<h1>Windows</h1>
<p>For now, the easiest way to get going is to install Linux on a virtual
machine, and follow the Linux instructions.</p>
<p>I hope to have better instructions for Windows soon; since I don’t have a
computer that runs it, I need to figure it out first. If you know how, this
would be a great way to <a href="https://github.com/intermezzOS/book">contribute</a></p>
<h1>Booting up</h1>
<p>We’ve got some of the theory down, and we’ve got a development environment
going. Let’s get down to actually writing some code, shall we?</p>
<p>Our first task is going to be the same as in any programming language: Hello
world! It’s going to take a <em>teeny</em> bit more code than in many languages. For
example, here’s “Hello, World!” in Ruby:</p>
<pre><code class="language-ruby">puts &quot;Hello, world!&quot;
</code></pre>
<p>Or in C:</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main(void) {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<p>But it’s not actually <em>that</em> much more work. It’s going to take us <em>28 lines</em>
to get there. And instead of a single command to build and run, like Ruby:</p>
<pre><code class="language-bash">$ ruby hello_world.rb
</code></pre>
<p>It’s going to initially take us six commands to build and run our hello world
kernel. Don’t worry, the next thing we’ll do is write a script to turn it back
into a single command.</p>
<h1>Multiboot headers</h1>
<p>Let’s get going! The very first thing we’re going to do is create a ‘multiboot
header’. What’s that, you ask? Well, to explain it, let’s take a small step
back and talk about how a computer boots up.</p>
<p>One of the amazing and terrible things about the x86 architecture is that it’s
maintained backwards compatibility throughout the years. This has been a
competitive advantage, but it’s also meant that the boot process is largely a
pile of hacks. Each time a new iteration comes out, a new step gets added to
the process. That’s right, when your fancy new computer starts up, it thinks
it’s an 8086 from 197?. And then, through a succession of steps, we transition
through each step.</p>
<p>The first mode is called ‘real mode’. This is a 16 bit mode that the original
x86 chips used. The second is ‘protected mode’. This 32 bit mode adds new
things on top of real mode. It’s called ‘protected’ because real mode sort of
let you do whatever you wanted, even if it was a bad idea. Protected mode was
the first time that the hardware enabled certain kinds of protections. We’ll
talk more about those details later.</p>
<p>The final mode is called ‘long mode’, and it’s 64 bits. Well, that’s actually a
lie: there’s two. Initially, you’re not in long mode, you’re in ‘compatibility
mode’. You see, when the industry was undergoing the transition from 32 to 64
bits, there were two options: the first was Intel’s Itanium 64-bit
architecture. It did away with all of the stuff I just told you about. But that
meant that programs had to be completely recompiled from scratch for the new
chips. Intel’s big competitor, AMD, saw an opportunity here, and released a new
set of chips called amd64. These chips were backwards compatible, and so you
could run both 32 and 64 bit programs on them. Itanium wasn’t compelling enough
to make the pain worth it, and so Intel released new chips that were compatible
with amd64. The resulting architecture was then called x86_64, the one we’re
using today. The moral of the story? Intel tried to save you from all of the
stuff we’re about to do, but they failed. So we have to do it.</p>
<p>Where was I... oh yes. Compatibility mode. So when you initially transition
to long mode, you’re not in <em>true</em> long mode; you’re in compatibility mode.
This is the ‘it all both works’ mode. From there, we can transition to
actual, honest-to-goodness long mode.</p>
<p>So that’s the task ahead of us: make the jump up the ladder and get to
long mode. We can do it! Let’s talk more details.</p>
<h2>Firmware and the BIOS</h2>
<p>COME BACK TO THIS LATER. I don’t know this well enough without internet,
and I’d rather be accurate than write it out wrong.</p>
<h2>Bootloaders</h2>
<p>The program that loads up our kernel is called a ‘bootloader’, since it loads
things at boot time. The bootloader’s job is to take our kernel, put it into
memory, and then transition control to it.</p>
<p>Some people start their operating systems journey by writing a bootloader. We
will not be doing that. Frankly, this whole startup process is more of an
exercise in reading manuals and understanding the history of esoteric hardware
than it is anything else. That stuff may interest you, and maybe someday we’ll
come back and write a bootloader of our own. But in the interest of actually
getting around to implementing a kernel, instead, we’ll use an existing
bootloader: GRUB.</p>
<h2>GRUB and Multiboot</h2>
<p>GRUB stands for ‘<em>gr</em>and <em>u</em>nified <em>b</em>ootloader’, and it’s a common one for
GNU/Linux systems. GRUB implements a specification called Multiboot, which is a
set of conventions for how a kernel should get loaded into memory. By following
the Multiboot specification, we can let GRUB load our kernel.</p>
<p>The way that we do this is through a ‘header’. We’ll put some information in a
format that multiboot specifies right at the start of our kernel. GRUB will
read this information, and follow it to do the right thing.</p>
<p>One other advantage of using GRUB: it will handle the transition from real mode
to protected mode for us, skipping the first step. We don’t even need to know
anything about all of that old stuff. If you’re curious about the kinds of
things you would have needed to know, put “A20 pin” into your favorite search
engine, and get ready to cry yourself to sleep.</p>
<h2>Writing our own Multiboot header</h2>
<p>I said we were gonna get to the code, and then I went on about more history.
Sorry about that! It’s code time for real! Let’s make a directory to contain
our project:</p>
<pre><code class="language-bash">$ mkdir intermezzOS
$ cd intermezzOS
</code></pre>
<p>A fun way to follow along is to pick a different name for your kernel, and
then change it as we go. Call your kernel whatever you want. intermezzOS was
almost called ‘Nucleus’, until I found out that there’s already a kernel with
that name that’s installed on billions of embedded devices. Whoops!</p>
<p>Inside that directory, make a new file called <code>multiboot_header.asm</code>, and
open it in your favorite editor. I use <code>vim</code>, but you should feel free to use
anything you’d like.</p>
<pre><code class="language-bash">$ touch multiboot_header.asm
$ vim multiboot_header.asm
</code></pre>
<p>Two notes about this: first of all, we’re just making this source file in the
top level. Don’t worry, we’ll clean house later. Remember: we’re going to build
stuff, and <em>then</em> abstract it afterwards. It’s easier to start with a mess and
clean it up than it is to try to get it perfect on the first try.</p>
<p>Second, this is a <code>.asm</code> file, which is short for ‘assembly’. That’s right, we’re
going to write some assembly code here. Don’t worry! It’s not super hard.</p>
<h3>An aside about assembly</h3>
<p>Have you ever watched Rich Hickey’s talk “Simple vs. Easy”? It’s a wonderful talk.
In it, he draws a distinction between these two words, which are commonly used as
synonyms. MORE STUFF GOES HERE BUT I WANT TO REWATCH THE TALK.</p>
<p>Assembly coding is simple, but that doesn’t mean that it’s easy. We’ll be doing
a little bit of assembly programming to build our operating system, but we
don’t need to know <em>that much</em>. It is completely learnable, even for someone
coming from a high-level language. You might need to practice a bit, and take
it slow, but I believe in you. You’ve got this.</p>
<h3>The Magic Number</h3>
<p>Our first assembly file will be almost entirely <em>data</em>, not code. Here’s the
first line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
</code></pre>
<p>Ugh! Gibberish! Let’s start with the semicolon (<code>;</code>). It’s a comment, that
lasts until the end of the line. This particular comment says ‘magic number’.
You’ll be seeing a lot of magic numbers in your operating system work. The idea
of a magic number is that it’s completely and utterly arbitrary. It doesn’t mean
anything. It’s just magic. The very first thing that the multiboot specification
requires is that we have the magic number <code>0xe85250d6</code> right at the start.</p>
<p>What’s the value in having an arbitrary number there? Well, it’s a kind of safeguard
against bad things happening. This is one of the ways in which we can check that
we actually have a real multiboot header. If it doesn’t have the magic number,
something has gone wrong, and we can throw an error.</p>
<p>I have no idea why it’s <code>0xe85250d6</code>, and I don’t need to care. It just is.</p>
<p>Finally, the <code>dd</code>. It’s short for ‘define DATA I THINK CRAP LOOK THIS UP’. It
declares that we’re going to stick some data at this location. Very
straightforward.</p>
<h3>The mode code</h3>
<p>Okay, time to add a second line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
dd 0          ; protected mode code
</code></pre>
<p>This is another form of magic number. We want to boot into protected mode, and
so we put a zero here, using <code>dd</code> again. If we wanted GRUB to do something
else, we could look up another code, but this is the one that we want.</p>
<h3>Header length</h3>
<p>The next thing that’s required is a header length. We could use <code>dd</code> and count
out exactly how many bytes that our header is, but there’s two reasons why
we’re not doing that:</p>
<ol>
<li>Computers should do math, not people.</li>
<li>We’re going to add more stuff, and we’d have to recalculate this number each
time. Or wait until the end and come back. See #1.</li>
</ol>
<p>Here’s what this looks like:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length
header_end:
</code></pre>
<p>You don’t have to align the comments if you don’t want to. I usually don’t, but
it looks nice and after we’re done with this file, we’re not going to mess with
it again, so we won’t be constantly re-aligning them in the future.</p>
<p>The <code>header_start:</code> and <code>header_end:</code> things are called ‘labels’. Labels let
us use a name to refer to particular part of our code. Our third <code>dd</code> line
uses those two labels to do some math: the header length is the value of
<code>header_end</code> minus the value of <code>header_start</code>. When we compile this assembly
code, the assembler will do this calculation for us. No need to figure out
how many bytes there are by hand. Awesome.</p>
<p>You’ll also notice that I indented the <code>dd</code> statements. Usually, labels go in
the first column, and you indent actual instructions. How much you indent is up
to you; it’s a pretty flexible format.</p>
<h3>The Checksum</h3>
<p>The fourth field multiboot requires is a ‘checksum’. The idea is that we sum up
some numbers, and then use that number to check that they’re all what we
expected things to be. It’s similar to a hash, in this sense: it lets us and GRUB
double-check that everything is accurate.</p>
<p>Here’s the checksum:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))
header_end:
</code></pre>
<p>Again, we’ll use math to let the computer calculate the sum for us. We add up
the magic number, the mode code, and the header length, and then subtract it
from a big number. <code>dd</code> then puts that value into this spot in our file.</p>
<p>DESRIBE WHY IT”S SUBTRACTED LATER BECAUSE THAT”S SPECIAL.</p>
<h3>Ending tag</h3>
<p>Finally, we have one more required bit: the end tag. it looks like this:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>Here we use <code>dw</code> to define a ‘word’ instead of just data. A word is SOME VALUE
bytes on the x86_64 architecture. The multiboot specification demands that this
be exactly a word. You’ll find that this is super common in operating systems:
the exact size and amount of everything matters. It’s just a side-effect of
working at a low level.</p>
<p>Anyway, we end up defining two zeroes and an eight. LOOK UP WHY THIS IS WHEN YOU
HAVE INTERNET STEVE.</p>
<h3>The Section</h3>
<p>We have one last thing to do: add a ‘section’ annotation. We’ll talk more about
sections later, so for now, just put what I tell you at the top of the file.</p>
<p>Here’s the final file:</p>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>That’s it! Congrats, you’ve written a multiboot compliant header. It’s a lot of
esoterica, but it’s pretty straightforward once you’ve seen it a few times.</p>
<h2>Assembling with <code>nasm</code></h2>
<p>We can’t use this file directly, we need to turn it into binary. We can use a
program called an ‘assembler’ to ‘assemble’ our assembly code into binary code.
It’s very similar to using a ‘compiler’ to ‘compile’ our source code into
binary. But when it’s assembly, people often use the more specific name.</p>
<p>We will be using an assembler called <code>nasm</code> to do this. You should invoke
<code>nasm</code> like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 multiboot_header.asm
</code></pre>
<p>The <code>-f elf64</code> says that we want to output a <em>f</em>ile with the type <code>elf64</code>.
ELF is a particular executable format that’s used by various UNIX systems,
and we’ll be using it too. There are other formats, but ELF is pretty good.</p>
<p>After you run this command, you should see a <code>multiboot_header.o</code> file in
the same directory. This is our ‘object file’, hence the <code>.o</code>. This is
the binary code, in ELF format. Later, we’ll take this file and use it
to build our OS.</p>
<h2>Summary</h2>
<p>Congratulations! This is the first step towards building an operating system.
We learned about the boot process, the GRUB bootloader, and the Multiboot
specification. We wrote a Multiboot-compliant header file in assembly code, and
used <code>nasm</code> to create an object file from it.</p>
<p>Next, we’ll write the actual code that prints “Hello world” to the screen.</p>
<h1>Hello, world!</h1>
<p>COMING SOON</p>
<h1>Making an ISO</h1>
<h1>Running in QEMU</h1>
<h1>Automation with Make</h1>
<h1>Source Control with Git</h1>
<h1>Transitioning to Long Mode</h1>
<h1>A Rust kmain()</h1>
<h1>A simple VGA driver</h1>
<h1>Keyboard input</h1>
<p>COMING SOON</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
