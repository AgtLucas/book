<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="what.html"><strong>1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong>1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong>1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong>1.4.</strong> What tools will we use?</a></li></ul></li><li><a href="setup.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="osx.html"><strong>2.2.</strong> Mac OS X</a></li><li><a href="windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="booting-up.html"><strong>3.</strong> Booting up</a></li><li><ul class="section"><li><a href="multiboot-headers.html"><strong>3.1.</strong> Multiboot headers</a></li><li><a href="hello-world.html"><strong>3.2.</strong> Hello, world!</a></li><li><a href="making-an-iso.html"><strong>3.3.</strong> Making an ISO</a></li><li><a href="running-in-qemu.html"><strong>3.4.</strong> Running in QEMU</a></li><li><a href="automation-with-make.html"><strong>3.5.</strong> Automation with Make</a></li><li><a href="source-control-with-git.html"><strong>3.6.</strong> Source Control with Git</a></li></ul></li><li><a href="transitioning-to-long-mode.html"><strong>4.</strong> Transitioning to Long Mode</a></li><li><a href="a-rust-kmain.html"><strong>5.</strong> A Rust kmain()</a></li><li><a href="simple-vga.html"><strong>6.</strong> A simple VGA driver</a></li><li><a href="keyboard-input.html"><strong>7.</strong> Keyboard input</a></li><li class="spacer"></li><li class="affix"><a href="appendix/numeral-systems.html">Appendix A: Numeral Systems</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">intermezzOS</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1 class="center">intermezzOS</h1>
<p><img class="center" src="rhizome.jpg" alt="rhizome" /></p>
<p class="center">An operating system for learning</p>
<h2>Preface</h2>
<p>This book describes the intermezzOS project. intermezzOS is a hobby operating
system, specifically targeted at showing beginners how to get into operating
systems development. Rather than describe some sort of final OS, it instead
proceeds in a tutorial-like fashion, allowing you to implement intermezzOS
yourself, alongside the book.</p>
<p>The book assumes that you have programmed in some language before, but not any
particular one. In fact, people who have not done low-level programming before
are a specific target of this book; I’ll be explaining a lot of things that
other resources will just assume that you know.</p>
<p>intermezzOS is implemented in <a href="https://www.rust-lang.org/">Rust</a>, and some
assembly code. We’ll try to explain Rust along the way, but may refer you to
its documentation when things get tricky. This book isn’t <em>really</em> about
learning Rust, but you might accidentally along the way.</p>
<p>You can find all of this stuff <a href="https://github.com/intermezzOS/">on GitHub</a>.
This book is in the <code>book</code> repository, the kernel is in <code>kernel</code>, and the
website is there too. Feel free to open issues on the <a href="https://github.com/intermezzOS/rfcs">RFCs
repo</a> if you want to discuss things
in a general sense, and send bug reports and PRs to the appropriate repos
if you’d like to help with a particular component.</p>
<h2>The Story</h2>
<p>A long time ago, in college, my friends and I were working on a hobby operating
system, <a href="http://xomb.org">XOmB</a>. It was... tough. Frankly, while I learned a
lot, I was a pretty minor contributor. I got frustrated too easily. One day, I
found Ruby, and I was pretty much done with low-level programming. I had done
it most of my life, and I was bored. Bored, and sick of dealing with core
dumps.</p>
<p>Those details aren’t that important. What is important is that over the years,
I’ve always wanted to get back into this stuff. But the problem is this: there
are a lot of people who do hobby operating system work, but... I don’t like
their attitudes.</p>
<p>You see, a lot of people see low-level programming as some kind of superior,
only-for-the-smartest kind of thing. They have a puritanical world-view: “I
suffered to learn this, so you too must suffer to build character.” I think
that’s short sighted. Low level programming <em>is</em> difficult to get into, but
that says more about the teachers’ faults than the students’.</p>
<p>Anyway, as my professional life has moved back towards the low level, I’ve been
thinking about this topic a lot again. That’s when I found an awesome link:
<a href="http://os.phil-opp.com/multiboot-kernel.html">Writing an OS in Rust by Philipp Oppermann</a>. I cannot speak enough
about how awesome Phil’s tutorial is; it single-handedly inspired me to get
back into operating systems.</p>
<p>The big difference with Phil’s tutorial is that it doesn’t treat you as being
stupid for not knowing ‘the basics’. It doesn’t say “spend hours debugging this
thing, because I did.” It doesn’t insult you for being new. It just explains
the basics of a kernel.</p>
<p>It’s amazing how much a little bit of a framing can completely change the way
you see something. When the examples I found were all about how you have to be
an amazing rockstar ninja and we won’t give you all the code because you suck
if you can’t figure it out, I hated this stuff. When it was kind,
understanding, and helpful, I couldn’t get enough.</p>
<p>Once I got to a certain part in Phil’s tutorial, I started implementing stuff
myself. A lot of the initial code here is going to be similar to Phil’s.
But I’m going to write about it anyway. There’s a good reason for that:</p>
<blockquote>
<p>Writing is nature’s way of showing us how sloppy our thinking is.</p>
<ul>
<li>Leslie Lamport</li>
</ul>
</blockquote>
<p>By re-explaining things in my own words, I hope to understand it even better.
This is just a perpetual theme with me: I like teaching because it helps me
learn. I like writing because it helps me understand.</p>
<p>The first section of the book is going to be clear about where we’re following
Phil, and where we break off and go into our own little world. After the start,
things will end up diverging.</p>
<p>Furthermore, I will not commit to any kind of schedule for this project. It’s
going to be in my spare time, and I’m learning a lot of this as I go, too.</p>
<h2>The Name</h2>
<blockquote>
<p>The nomad has a territory; he follows customary paths; he goes from one point
to another; he is not ignorant of points (water points, dwelling points,
assembly points, etc.). But the question is what in nomad life is a principle
and what is only a consequence. To begin with, although the points determine
paths, they are strictly subordinated to the paths they determine, the
reverse happens with the sedentary. The water point is reached only in order
to be left behind; every point is a relay and exists only as a relay. A path
is always between two points, but the in-between has taken on all the
consistency and enjoys both an autonomy and a direction of its own. The life
of the nomad is the intermezzo.</p>
<p>Deleuze and Guattari, “A Thousand Plateaus”, p380</p>
</blockquote>
<p>If you’re not into particular kinds of philosophy, this quote won’t mean a lot.
Let’s look at the dictionary definition:</p>
<blockquote>
<p>An intermezzo, in the most general sense, is a composition which fits between
other musical or dramatic entities, such as acts of a play or movements of a
larger musical work.</p>
<p><a href="https://en.wikipedia.org/wiki/Intermezzo">https://en.wikipedia.org/wiki/Intermezzo</a></p>
</blockquote>
<p>I want this project to be about learning. Learning is often referred to as a
journey. You start off in ignorance and end in knowledge. In other words,
‘learning’ is that part in the middle, the in-between state.</p>
<p>The tricky thing about learning is, you never stop learning. Once you learn
something, there’s something new to learn, and you’re on a journey again.</p>
<p>If you want to learn a lot, then you’ll find yourself perpetually in the
middle.</p>
<p>There is another sense by which this name makes sense: as we’ll learn in the
beginning of the book, operating systems are largely about abstractions. And
abstractions are themselves ‘in the middle’, between what they’re abstracting
and who they are abstracting it for.</p>
<h2>Principles</h2>
<p>Here are the guiding principles of intermezzOS:</p>
<ul>
<li>We’re all actual people. Please treat each other as such.</li>
<li>We’re all here to learn. Let’s help each other learn, rather than being some
kind of vanguard of knowledge.</li>
<li>The only thing that matters about your language background is the amount you
may have to learn.</li>
<li>Everything must be documented, or it’s not done.</li>
</ul>
<p>And of course, everything related to this project is under the <a href="http://intermezzos.github.io/code-of-conduct.html">Code of
Conduct</a>.</p>
<h1>Background</h1>
<p>Before we get going, we should probably have some idea of where we’re headed.</p>
<h1>What is an OS?</h1>
<p>It’s actually kind of difficult to define what an operating system is. There
are a lot of different kinds of operating systems, and they all do different
kinds of things.</p>
<p>Some things are commonly bundled with operating systems, but are arguably not
part of the essence of what makes an OS an OS. For example, many operating
systems are often marketed as coming equipped with a web browser or email
client. Are web browsers and email clients essential to operating systems?
Many would argue the answer is no.</p>
<p>There are some shared goals we can find among all operating systems, however.
Let’s try this out as a working definition:</p>
<blockquote>
<p>An operating system is a program that provides a platform for other
programs. It provides two things to these programs: abstractions and
isolation.</p>
</blockquote>
<p>This is good enough for now. Let’s consider this a test for inclusion,
but not exclusion. In other words, things that fit this definition
<em>are</em> operating systems, but things that don’t may or may not be,
we don’t quite know.</p>
<h2>Creating abstractions</h2>
<p>There are many reasons to create a platform for other programs, but a
common one for operating systems is to abstract over hardware.</p>
<p>Consider a program, running on some hardware:</p>
<p><img alt="program on hardware" class="center" src="assets/program_hardware.png" /></p>
<p>This program will need to know <em>exactly</em> about what kind of hardware exists.
If you want to run it on a different computer, it will have to know exactly
about that computer too. And if you want to write a second program, you’ll
have to re-write a bunch of code for interacting with the hardware.</p>
<blockquote>
<p>All problems in computer science can be solved by another level of
indirection.</p>
<ul>
<li>David Wheeler</li>
</ul>
</blockquote>
<p>To solve this problem, we can introduce an abstraction:</p>
<p><img alt="program on os on hardware" class="center" src="assets/program_os_hardware.png" /></p>
<p>Now, the operating system can handle the details of the hardware, and provide
an API for it. A program can be written for that operating system’s API, and
can then run on any hardware that the operating system supports.</p>
<p>At some point, though, we developed many operating systems. Since operating
systems are platforms, most people pick one and have only that one on their
computer. So now we have a problem that looks the same, but is a bit
different: our program is now specific to an OS, rather than specific to
a particular bit of hardware.</p>
<p>To solve this, some programming languages have a ‘virtual machine.’ This
was a big selling point of Java, for example: the Java Virtual Machine.
The idea here is that we create a <em>virtual</em> machine on top of the <em>real</em>
machine.</p>
<p><img alt="program on vm " class="center" src="assets/program_vm_os_hardware.png" /></p>
<p>Now, you write programs for the Java Virtual Machine, which is then ported
to each operating system, which is then ported to all the hardware. Whew!</p>
<p>This, of course, leads to the corollary to the previous maxim:</p>
<blockquote>
<p>...except for the problem of too many layers of indirection.</p>
<ul>
<li>Kevlin Henney</li>
</ul>
</blockquote>
<p>We now have a pattern:</p>
<ul>
<li>I have <code>A</code>.</li>
<li><code>A</code> is written explicitly for <code>X</code>...</li>
<li>... but I want to support <code>X</code> and <code>Y</code>,</li>
<li>so I put abstraction <code>B</code> in the middle.</li>
</ul>
<p>We will see this pattern over and over again. Hence ‘intermezzo’: abstractions
are always in the middle.</p>
<h2>Isolation</h2>
<p>Many of the abstractions provided are, as we discussed, abstractions over
hardware. And hardware often has a pretty serious restriction: only one
program can access the hardware at a time. So if our operating system is going
to be able to run multiple programs, which is a common feature of many
operating systems, we’ll also need to make sure that multiple programs cannot
access hardware at the same time.</p>
<p>This really applies to more than just hardware though: it also applies to
shared resources (e.g. memory). Once we have two programs, it would
be ideal to not let them mess with each other. Consider any sort of program that
deals with your password: if programs could mess with each other’s memory
and code, then a program could trivially steal your password from another program!</p>
<p>This is just one symptom of a general problem. It’s much better to isolate
programs from each other, for a number of different reasons. For now, we’ll
just consider isolation as one of our important jobs, as OS authors.</p>
<h3>Wait a minute...</h3>
<p>Here’s a question for you to ponder: if we didn’t provide isolation, isn’t that
just a poor abstraction? In other words, if we had an abstraction where we
could interact with other things being abstracted... isn’t that just a bad job
of doing the abstraction? And in that sense, is the only thing an operating
system does abstraction? Is the only thing everything does abstraction?</p>
<p>I don’t have answers for you. If you figure it out, let me know...</p>
<h1>What kinds of OS are there?</h1>
<p>Okay, so here’s the thing: operating systems are made up of a <em>lot</em> of components.
The core component is called a ‘kernel’. The non-kernel bits of an operating system
are collectively called a ‘userland’. Typically a kernel has more direct access to the
machine than a userland and thus acts somewhat like a super user (with powers that even
‘sudo’ cannot give you). A kernel forms the basis of the abstractions and isolations.
So, as OS developers, when we categorize operating systems, we tend to categorize them
by what kinds of kernel they have.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>Although you may be used to hearing the term ‘Linux’ used as a name for an
operating system, you may hear some people say, “It’s GNU/Linux, not Linux.”
That’s because virtually all Linux distributions today use a Linux kernel + a
GNU userland. So the GNU folks are a bit annoyed that the kernel gets all
the credit. By the same token, a lot of people say ‘the kernel’ when they mean
‘the Linux kernel.’ This gets an entirely different set of people mad.</p>
</blockquote>
<p>At the start, our ‘operating system’ will be just the kernel, and so we’ll tend
to focus on kernels for the first part of our journey.</p>
<p>The way that we categorize different kernels largely comes down to “what is in
the kernel and what is in userspace.” Upon reading this, you might then think
the easiest kind of kernel to write is the smallest, where everything is in
userspace. After all, smaller should be easier, right? Well... that’s not
actually true. Or at least, it’s not clear that it’s true.</p>
<h2>Monolithic kernels</h2>
<p>First, we have ‘monolithic kernels’. ‘Mono’ meaning ‘one’. One big ‘ol kernel.
Most real-world kernels are monolithic kernels, or at least, pretend to be.
Don’t worry about it. Linux, for example, is a monolithic kernel.</p>
<p>This means that monolithic kernels are kind of ‘the default’. Other kernels
usually define themselves by solving some kind of problem that monolithic
kernels have.</p>
<p>If a monolithic kernel were a web application, it would be a big ‘ol Rails
application. One repository. A million subdirectories. It may be a big ball
of mud, but it pays the bills.</p>
<h2>Microkernels</h2>
<p>Microkernels are, well, micro. Smaller. A lot of the functionality that’s typically in
the kernel is in userspace instead. This is a good idea in theory, but
historically, microkernels have had issues. All that communication has
overhead, which makes them slower.</p>
<p>Mach, the kernel that Mac OS X uses, is a microkernel. Well, sort of. It ended
up being one, but Mac OS X uses a version of Mach from before that work was
done... so it’s a bit blurry.</p>
<p>If a microkernel were a web application, it would be a microservice. And a
bunch of the other stuff that’s in kernel space in a monolithic kernel are
other microservices, but in userspace instead. It’s a bit cooler than a single
monolithic web app by itself, and the communication is nice for flexibility’s
sake, but has some overhead.</p>
<h2>Exokernels &amp; Unikernels</h2>
<p>These two kinds of operating systems are closely related, but it’s a bit harder
to dig into what exactly makes them different. Unikernels have one
easy-to-describe feature: they only run one single program at a time.
Exokernels are ‘more micro than micro’, but the details aren’t important right
now.</p>
<p>The important thing to know here is that there are a lot of other kinds of
designs than just monolithic vs. micro. There’s a lot of stuff to learn!</p>
<h1>What kind are we making?</h1>
<p>So, given all these kinds of operating systems, what kind are we making?</p>
<p>The answer is “it doesn’t even matter at first.” There’s some commonality in
almost all of these styles of operating systems, and we have to get all that
done before we even make those decisions.</p>
<p>Secondly, we could waste a <em>lot</em> of time trying to design our perfect OS. And
then never actually build it. Remember, the goal here is <em>to learn</em>, not <em>to
make the best OS that ever existed</em>. So really, what it ends up looking like
just doesn’t really matter at all. Most hobby operating system projects die
quite young.</p>
<p>Let’s focus on the <em>doing</em>, and less on the categorization, planning, and
being. A nice thing about operating systems is that there’s a lot of freedom of
direction. To tie it back into the example earlier, Phil’s tutorial starts
going into memory-management after getting printing to the screen going. We’ll
be going into keyboards first instead. There are, of course, some dependencies,
but there’s also a lot of freedom.</p>
<h1>What tools will we use?</h1>
<p>Before we can make a kernel, we need to figure out the tools we’re going to
use. The first question, of course, is what programming language?</p>
<p>In our case, we’re going to use two. The first one is the language that
<em>every</em> kernel must use: assembly language.</p>
<h2>Assembly</h2>
<p>Assembly language gives us direct access to a specific machine. If the basis of
computer science is abstraction, the very bottom of the software abstraction layer
is assembly. Below it lies only hardware and physics.</p>
<p>There are many kinds of assembly languages each targeted at different
‘instruction set’ architectures (also known as ISA or simply as instruction sets).
These instruction sets are the list of commands that a given CPU can understand. For
example, if your computer has an Intel Pentium processor of some kind then it
understands the x86 instruction set. So if you were to write assembly for another
instruction set (say MIPS or ARM), you would not be able to run it on your computer.</p>
<p>This is one of the reasons we'll want to get away from the assembly world as
fast as possible. If we want our kernel to work for a bunch of different
architectures, any code we end up writing in assembly will need to be duplicated.
However, if we use a more high-level language like C, C++ or the language we'll
really be using, Rust, we can write the code once and cross-compile
to different architectures.</p>
<p>Assembly language looks like this:</p>
<pre><code class="language-x86asm">; foo.asm

section .data
global _start

_start:
    mov rax, 0
loop:
    add rax, 1
    cmp rax, 10
    jne loop

    mov rbx, rax
    mov rax, 1
    int 80h
</code></pre>
<p>This is a little program in assembly language. If it looks totally alien to you,
don't worry. While we could write our entire kernel in assembly, we'll only be
learning as much assembly as we need to not have to use it any more.</p>
<p>When you write asssembly language you are actually directly manipulating the
individual registers of the CPU and memory inside of RAM and other hardware
devices like CD drives or display screens.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>CPUs are composed of registers each of which can only hold small amounts of data.
The amount of data a register can hold dictates what type of CPU the register
belongs to. If you didn't know why your machine is classified as either 32 bit
or 64 bit it's because the machine's registers can either hold 32 bits of data at a
time or 64 bits at a time.</p>
</blockquote>
<p>In assembly we can only do very simple things: move data between registers or
to/from RAM; perform simple arithmetic like addition, substraction, multiplication
and division; compare values in different registers, and based on these comparisons
jump to different points in our code (á la GOTO). Fancy high level concepts
like while loops and if statements, let alone garabage collection are nowhere to be
found. Even functions as you know them aren't really supported in assembly.
Each assembly program is just a bunch of data in registers or in memory and a
list of instructions, carried out one after the other.</p>
<p>For instance, in our code above we used the <code>mov</code> instruction several times to
move values into specific registers with weird names like <code>rax</code> and <code>rbx</code>. We
used the <code>cmp</code> instruction to to compare the value inside of the <code>rax</code> register
with the number <code>10</code>. We used the <code>jne</code> instruction to jump to another part of
our code if the numbers we just compared were not equal. Finally we used the <code>int</code>
instruction to trigger a hardware <em>int</em>errupt.</p>
<p>Again, you don't need to fully understand this program at this point. Right now
you should just have an impression for how assembly is composed of simple
instructions that do very simple things.</p>
<p>When it comes time to write some actual assembly code we'll touch on all this again.</p>
<p>Let's run this little program:</p>
<pre><code class="language-bash">$ nasm -f elf64 foo.asm # assemble into foo.o
$ ld foo.o              # link into a.out
$ ./a.out               # run it
$ echo $?               # print out the exit code
10
$
</code></pre>
<p>Don't worry too much about what programs we're using to actually compile (or
‘assemble’ as it's known in the assembly world) our program. We'll be going
over each one of these commands and explaining what they are and how to use
them.</p>
<h2>Rust</h2>
<p>We will augment our assembly with code written in
<a href="https://www.rust-lang.org/">Rust</a>. In fact, we will be trying to get to
Rust-land as quickly as we possibly can. Rust is a really great programming
language, and it’s pretty great for writing operating systems. It has some
rough edges, but they’re not too big of a deal.</p>
<p>Rust will allow us to write:</p>
<pre><code class="language-rust">// foo.rs

use std::process;

fn main() {
    let mut a = 0;

    for _ in 0..10 {
        a = a + 1;
    }

    process::exit(a);
}
</code></pre>
<p>This does the same thing as our assembly code:</p>
<pre><code class="language-bash">$ rustc foo.rs # compile our Rust code to foo
$ ./foo        # run it
$ echo $?      # print out the exit code
10
$
</code></pre>
<p>That Rust code probably looks more like a programming language you’ve used in
the past. It’s a lot nicer to write complex things in a higher-level
programming language like Rust. That said, virtually all languages are
higher-level than assembly, so that’s not saying all that much. Rust is still a
low-level language by many standards.</p>
<p>So why choose Rust? Well, I’m picking it for two reasons:</p>
<ol>
<li>I love it.</li>
<li>There aren’t a lot of kernels in it yet.</li>
</ol>
<p>There are a suprising number of people working on kernels in Rust. But since
it’s a newer language, there aren’t nearly as many as for older, more
established languages.</p>
<h2>Do I need to be a wizard?</h2>
<p>No, you do not. A common theme of this project is “this is all we’ll need to
know about this topic for now.” There’s no reason that you need to absolutely
master everything before going forward. For example, in order to get Rust
going, we need only about 100 lines of assembly, as mentioned above. Do you
need to be a complete expert in assembly language to understand those well
enough to keep going? Not at all. Will learning more about it help? Absolutely!</p>
<p>There’s nobody that’s monitoring your credentials to see if you’re allowed to
move on. Do it at your own pace. Skip stuff. Come back when you don’t
understand what’s going on. Try it, wait a week, and then try it again.</p>
<p>There’s no wrong way to do this stuff, including by being a beginner. Everyone
was once. Don’t let anyone discourage you.</p>
<h1>Setting up a development environment</h1>
<p>Frankly, one of the hardest parts of starting an operating system is getting a
development environment going. Normally, you’re doing work on the same
operating system you’re developing for, and we don’t have that luxury. Yet!</p>
<p>There is a convention called a ‘target triple’ to describe a particular
platform. It’s a ‘triple’ because it has three parts:</p>
<pre><code class="language-text">arch-kernel-userland
</code></pre>
<p>So, a target triple for a computer which has an x86-64 bit processor running a
Linux kernel and the GNU userland would look like this:</p>
<pre><code class="language-text">x86_64-linux-gnu
</code></pre>
<p>However, it can also be useful to know the operating system as well, and so
the ‘triple’ part can be extended to include it:</p>
<pre><code class="language-text">x86_64-unknown-linux-gnu
</code></pre>
<p>This is for some unknown Linux. If we were targeting Debian specifically, it
would be:</p>
<pre><code class="language-text">x86_64-debian-linux-gnu
</code></pre>
<p>Since it’s four parts, it’s called a ‘target’ rather than a ‘target triple’,
but you’ll still hear some people call it a triple anyway.</p>
<p>Kernels themselves don’t need to be for a specific userland, and so you’ll
see ‘none’ get used:</p>
<pre><code class="language-text">x86_64-unknown-none
</code></pre>
<h2>Hosts &amp; Targets</h2>
<p>The reason that they’re called a ‘target’ is that it’s the architecture you’re
compiling <em>to</em>. The architecture you’re compiling <em>from</em> is called the ‘host
architecture’.</p>
<p>If the target and the host are the same, we call it ‘compiling’. If they are
different, we call it ‘cross-compiling’. So you’ll see people say things like</p>
<blockquote>
<p>I cross-compiled from x86_64-linux-gnu to x86-unknown-none.</p>
</blockquote>
<p>This means that the computer that the developer was using was a 64-bit
GNU/Linux machine, but the final binary was for a 32-bit x86 machine with no
OS.</p>
<p>So we need a slightly special environment to build our OS: we need to
cross-compile from whatever kind of computer we are using to our new target.</p>
<h2>Cheat codes</h2>
<p>... but we can also cheat. It’s okay to cheat. Well, in this case, it’s really
only okay at the start. We’ll eventually <em>have</em> to cross-compile, or things
will go wrong.</p>
<p>Here’s the cheat: if you are developing on an x86_64 Linux machine, and you’re
not using any special Linux kernel features, then the difference between
<code>x86_64-linux-gnu</code> and <code>x86_64-unknown-none</code> is really just theoretical. It
will still technically <em>work</em>. For now.</p>
<p>This is a common pitfall with new operating system developers. They’ll start
off with the cheat, and it will come back to haunt them later. Don’t worry;
I will actually show you how to fix things before they go wrong. Knowing the
difference here is still useful.</p>
<h1>Linux</h1>
<p>Here are the tools we’re going to need:</p>
<ul>
<li>Rust</li>
<li><code>nasm</code></li>
<li><code>ld</code></li>
<li><code>grub-mkrescue</code> + <code>xorriso</code></li>
<li><code>qemu</code></li>
</ul>
<p>To install Rust, check out <a href="https://github.com/brson/multirust">multirust</a>.</p>
<p>Once you have it installed, grab a nightly build:</p>
<pre><code class="language-bash">$ multirust update PUT NIGHTLY HERE
$ multirust default PUT NIGHTLY HERE
</code></pre>
<p>TODO: https://github.com/intermezzOS/book/issues/26</p>
<p>To install the other tools, on Debian:</p>
<pre><code class="language-bash">$ sudo apt-get install nasm xorriso qemu
</code></pre>
<h1>Mac OS X</h1>
<p>For now, the easiest way to get going is to install Linux on a virtual
machine, and follow the <a href="./linux.html">Linux instructions</a>.</p>
<p>Otherwise, to install the other tools on Mac OS X, make sure to have <a href="http://brew.sh/">homebrew</a> installed.</p>
<p>Then you can run the following command:</p>
<pre><code>brew install nasm xorriso qemu
</code></pre>
<h1>Windows</h1>
<p>For now, the easiest way to get going is to install Linux on a virtual
machine, and follow the <a href="./linux.html">Linux instructions</a>.</p>
<p>I hope to have better instructions for Windows soon; since I don’t have a
computer that runs it, I need to figure it out first. If you know how, this
would be a great way to <a href="https://github.com/intermezzOS/book">contribute</a>.</p>
<h1>Booting up</h1>
<p>We’ve got some of the theory down, and we’ve got a development environment
going. Let’s get down to actually writing some code, shall we?</p>
<p>Our first task is going to be the same as in any programming language: Hello
world! It’s going to take a <em>teeny</em> bit more code than in many languages. For
example, here’s “Hello, World!” in Ruby:</p>
<pre><code class="language-ruby">puts &quot;Hello, world!&quot;
</code></pre>
<p>Or in C:</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main(void) {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<p>But it’s not actually <em>that</em> much more work. It’s going to take us <em>28 lines</em>
to get there. And instead of a single command to build and run, like Ruby:</p>
<pre><code class="language-bash">$ ruby hello_world.rb
</code></pre>
<p>It’s going to initially take us six commands to build and run our hello world
kernel. Don’t worry, the next thing we’ll do is write a script to turn it back
into a single command.</p>
<h1>Multiboot headers</h1>
<p>Let’s get going! The very first thing we’re going to do is create a ‘multiboot
header’. What’s that, you ask? Well, to explain it, let’s take a small step
back and talk about how a computer boots up.</p>
<p>One of the amazing and terrible things about the x86 architecture is that it’s
maintained backwards compatibility throughout the years. This has been a
competitive advantage, but it’s also meant that the boot process is largely a
pile of hacks. Each time a new iteration comes out, a new step gets added to
the process. That’s right, when your fancy new computer starts up, it thinks
it’s an 8086 from 1976. And then, through a succession of steps, we transition
through more and more modern architectures until we end at the latest and
greatest.</p>
<p>The first mode is called ‘real mode’. This is a 16 bit mode that the original
x86 chips used. The second is ‘protected mode’. This 32 bit mode adds new
things on top of real mode. It’s called ‘protected’ because real mode sort of
let you do whatever you wanted, even if it was a bad idea. Protected mode was
the first time that the hardware enabled certain kinds of protections that allow
us to exercise more control around such things as RAM. We’ll talk more about
those details later.</p>
<p>The final mode is called ‘long mode’, and it’s 64 bits.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>Well, that’s actually a lie: there’s two. Initially, you’re not in long mode,
you’re in ‘compatibility mode’. You see, when the industry was undergoing the
transition from 32 to 64 bits, there were two options: the first was Intel’s
Itanium 64-bit architecture. It did away with all of the stuff I just told
you about. But that meant that programs had to be completely recompiled from
scratch for the new chips. Intel’s big competitor, AMD, saw an opportunity
here, and released a new set of chips called amd64. These chips were backwards
compatible, and so you could run both 32 and 64 bit programs on them.
Itanium wasn’t compelling enough to make the pain worth it, and so Intel released
new chips that were compatible with amd64. The resulting architecture was then
called x86_64, the one we’re using today. The moral of the story? Intel tried
to save you from all of the stuff we’re about to do, but they failed. So
we have to do it.</p>
</blockquote>
<p>So that’s the task ahead of us: make the jump up the ladder and get to
long mode. We can do it! Let’s talk more details.</p>
<h2>Firmware and the BIOS</h2>
<p>So let's begin by turning the power to our computer on.</p>
<p>When we press the power button, electricity starts running, and a special piece of
software, known as the BIOS in Intel land, automatically runs.</p>
<p>With the BIOS we're already in the land of software, but unlike software that
you may be used to writing, the BIOS comes bundled with its computer and is located in
<em>r</em>ead-<em>o</em>nly <em>m</em>emory (ROM). While changing or updating stuff in ROM
is possible, it's not something you can do by invoking your favorite
package manager or by downloading something from some website. In fact some ROM
is literally hardwired into the computer and cannot be changed without
physically swapping it out. This makes sense here. The BIOS and the
computer are lifetime partners. Their existence doesn't make much sense without
each other.</p>
<p>One of the first things the BIOS does is run a ‘POST’ or <em>p</em>ower-<em>o</em>n <em>s</em>elf-<em>t</em>est
which checks for the availability and integrity of all the pieces of hardware that
the computer needs including the BIOS itself, CPU registers, RAM, etc. If you've
ever heard a computer beeping at you as it boots up, that's the POST reporting
its findings.</p>
<p>Assuming no problems are found, the BIOS starts the real booting process.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>For a while now most commercial computer manufacturers have hidden their BIOS
booting process behind some sort of splash screen. It's usually possible to see the
BIOS' logs by pressing some collection of keys when your computer is starting up.</p>
<p>The BIOS also has a menu where you can see information about the computer
like CPU and memory specs and all the hardware the BIOS detected like hard drives
and CD and DVD drives. Typically this menu is accessed by pressing some other
weird collection of keyboard keys while the computer is attempting to boot.</p>
</blockquote>
<p>The BIOS automatically finds a ‘bootable drive’ by looking in certain
pre-determined places like the computer's hard drive and CD and DVD drives.
A drive is ‘bootable’ if it contains software that can finish the booting
process. In the BIOS menu you can usually change in what order the BIOS looks
for bootable drives or tell it to boot from a specific drive.</p>
<p>The BIOS knows it's found a bootable drive by looking at the first few kilobytes
of the drive and looking for some magical numbers set in that drive's
memory. This won't be the last time some magical numbers or hacky sounding things
are used on our way to building an OS. Such is life at such a low level...</p>
<p>When the BIOS has found its bootable drive, it loads part of the drive into
memory and transfers execution to it. With this process, we move away from what
comes dictated by the computer manufacturer and move ever closer to getting our
OS running.</p>
<h2>Bootloaders</h2>
<p>The part of our bootable drive that gets executed is called a ‘bootloader’,
since it loads things at boot time. The bootloader’s job is to take our kernel,
put it into memory, and then transition control to it.</p>
<p>Some people start their operating systems journey by writing a bootloader. We
will not be doing that. Frankly, this whole startup process is more of an
exercise in reading manuals and understanding the history of esoteric hardware
than it is anything else. That stuff may interest you, and maybe someday we’ll
come back and write a bootloader of our own.</p>
<p>In the interest of actually getting around to implementing a kernel, instead, we’ll
use an existing bootloader: GRUB.</p>
<h2>GRUB and Multiboot</h2>
<p>GRUB stands for ‘<em>gr</em>and <em>u</em>nified <em>b</em>ootloader’, and it’s a common one for
GNU/Linux systems. GRUB implements a specification called Multiboot, which is a
set of conventions for how a kernel should get loaded into memory. By following
the Multiboot specification, we can let GRUB load our kernel.</p>
<p>The way that we do this is through a ‘header’. We’ll put some information in a
format that multiboot specifies right at the start of our kernel. GRUB will
read this information, and follow it to do the right thing.</p>
<p>One other advantage of using GRUB: it will handle the transition from real mode
to protected mode for us, skipping the first step. We don’t even need to know
anything about all of that old stuff. If you’re curious about the kinds of
things you would have needed to know, put “A20 pin” into your favorite search
engine, and get ready to cry yourself to sleep.</p>
<h2>Writing our own Multiboot header</h2>
<p>I said we were gonna get to the code, and then I went on about more history.
Sorry about that! It’s code time for real! Let’s make a directory to contain
our project:</p>
<pre><code class="language-bash">$ mkdir intermezzOS
$ cd intermezzOS
</code></pre>
<p>A fun way to follow along is to pick a different name for your kernel, and
then change it as we go. Call your kernel whatever you want. intermezzOS was
almost called ‘Nucleus’, until I found out that there’s already a kernel with
that name that’s installed on billions of embedded devices. Whoops!</p>
<p>Inside that directory, make a new file called <code>multiboot_header.asm</code>, and
open it in your favorite editor. I use <code>vim</code>, but you should feel free to use
anything you’d like.</p>
<pre><code class="language-bash">$ touch multiboot_header.asm
$ vim multiboot_header.asm
</code></pre>
<p>Two notes about this: first of all, we’re just making this source file in the
top level. Don’t worry, we’ll clean house later. Remember: we’re going to build
stuff, and <em>then</em> abstract it afterwards. It’s easier to start with a mess and
clean it up than it is to try to get it perfect on the first try.</p>
<p>Second, this is a <code>.asm</code> file, which is short for ‘assembly’. That’s right, we’re
going to write some assembly code here. Don’t worry! It’s not super hard.</p>
<h3>An aside about assembly</h3>
<p>Have you ever watched Rich Hickey’s talk “Simple vs. Easy”? It’s a wonderful talk.
In it, he draws a distinction between these two words, which are commonly used as
synonyms.</p>
<p>TODO https://github.com/intermezzOS/book/issues/27</p>
<p>Assembly coding is simple, but that doesn’t mean that it’s easy. We’ll be doing
a little bit of assembly programming to build our operating system, but we
don’t need to know <em>that much</em>. It is completely learnable, even for someone
coming from a high-level language. You might need to practice a bit, and take
it slow, but I believe in you. You’ve got this.</p>
<h3>The Magic Number</h3>
<p>Our first assembly file will be almost entirely <em>data</em>, not code. Here’s the
first line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
</code></pre>
<p>Ugh! Gibberish! Let’s start with the semicolon (<code>;</code>). It’s a comment, that
lasts until the end of the line. This particular comment says ‘magic number’.
As we said, you’ll be seeing a lot of magic numbers in your operating system work.
The idea of a magic number is that it’s completely and utterly arbitrary. It
doesn’t mean anything. It’s just magic. The very first thing that the multiboot
specification requires is that we have the magic number <code>0xe85250d6</code> right
at the start.</p>
<p>What’s the value in having an arbitrary number there? Well, it’s a kind of safeguard
against bad things happening. This is one of the ways in which we can check that
we actually have a real multiboot header. If it doesn’t have the magic number,
something has gone wrong, and we can throw an error.</p>
<p>I have no idea why it’s <code>0xe85250d6</code>, and I don’t need to care. It just is.</p>
<p>Finally, the <code>dd</code>. It’s short for ‘define double word’. It declares that we’re
going to stick some 32-bit data at this location. Remember, when x86 first started,
it was a 16-bit architecture set. That meant that the amount of data that could be
held in a CPU register (or one ‘word’ as it's commonly known) was 16 bits.
To transition to a 32-bit architecture without losing backwards compatibility,
x86 got the concept of a ‘double word’ or double 16 bits.</p>
<h3>The mode code</h3>
<p>Okay, time to add a second line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
dd 0          ; protected mode code
</code></pre>
<p>This is another form of magic number. We want to boot into protected mode, and
so we put a zero here, using <code>dd</code> again. If we wanted GRUB to do something
else, we could look up another code, but this is the one that we want.</p>
<h3>Header length</h3>
<p>The next thing that’s required is a header length. We could use <code>dd</code> and count
out exactly how many bytes that our header is, but there’s two reasons why
we’re not doing that:</p>
<ol>
<li>Computers should do math, not people.</li>
<li>We’re going to add more stuff, and we’d have to recalculate this number each
time. Or wait until the end and come back. See #1.</li>
</ol>
<p>Here’s what this looks like:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length
header_end:
</code></pre>
<p>You don’t have to align the comments if you don’t want to. I usually don’t, but
it looks nice and after we’re done with this file, we’re not going to mess with
it again, so we won’t be constantly re-aligning them in the future.</p>
<p>The <code>header_start:</code> and <code>header_end:</code> things are called ‘labels’. Labels let
us use a name to refer to a particular part of our code. Labels also refer to the
memory occupied by the data and code which directly follows it. So in our code above
the label <code>header_start</code> points directly to the memory at the very beginning of our
magic number and thus to the very beginning of our header.</p>
<p>Our third <code>dd</code> line uses those two labels to do some math: the header length is
the value of <code>header_end</code> minus the value of <code>header_start</code>. Because <code>header_start</code>
and <code>header_end</code> are just the addresses of places in memory, we can simply subtract
to get the distance between those two addresses. When we compile this assembly
code, the assembler will do this calculation for us. No need to figure out
how many bytes there are by hand. Awesome.</p>
<p>You’ll also notice that I indented the <code>dd</code> statements. Usually, labels go in
the first column, and you indent actual instructions. How much you indent is up
to you; it’s a pretty flexible format.</p>
<h3>The Checksum</h3>
<p>The fourth field multiboot requires is a ‘checksum’. The idea is that we sum up
some numbers, and then use that number to check that they’re all what we
expected things to be. It’s similar to a hash, in this sense: it lets us and GRUB
double-check that everything is accurate.</p>
<p>Here’s the checksum:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))
header_end:
</code></pre>
<p>Again, we’ll use math to let the computer calculate the sum for us. We add up
the magic number, the mode code, and the header length, and then subtract it
from a big number. <code>dd</code> then puts that value into this spot in our file.</p>
<p>TODO: https://github.com/intermezzOS/book/issues/28</p>
<h3>Ending tag</h3>
<p>After the checksum you can list a series of “tags”, which is a way for the OS to
tell the bootloader to do some extra things before handing control over to the
OS, or to give the OS some extra information once started. We donʼt need any of
that yet, though, so we just need to include the required “end tag”, which looks
like this:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>Here we use <code>dw</code> to define a ‘word’ instead of just data. Remember a ‘word’ is 16
bits or 2 bytes on the x86_64 architecture. The multiboot specification demands
that this be exactly a word. You’ll find that this is super common in operating systems:
the exact size and amount of everything matters. It’s just a side-effect of
working at a low level.</p>
<h3>The Section</h3>
<p>We have one last thing to do: add a ‘section’ annotation. We’ll talk more about
sections later, so for now, just put what I tell you at the top of the file.</p>
<p>Here’s the final file:</p>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>That’s it! Congrats, you’ve written a multiboot compliant header. It’s a lot of
esoterica, but it’s pretty straightforward once you’ve seen it a few times.</p>
<h2>Assembling with <code>nasm</code></h2>
<p>We can’t use this file directly, we need to turn it into binary. We can use a
program called an ‘assembler’ to ‘assemble’ our assembly code into binary code.
It’s very similar to using a ‘compiler’ to ‘compile’ our source code into
binary. But when it’s assembly, people often use the more specific name.</p>
<p>We will be using an assembler called <code>nasm</code> to do this. You should invoke
<code>nasm</code> like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 multiboot_header.asm
</code></pre>
<p>The <code>-f elf64</code> says that we want to output a <em>f</em>ile with the type <code>elf64</code>.
ELF is a particular executable format that’s used by various UNIX systems,
and we’ll be using it too. The executable format just specifies how exactly the
bits will be laid out in the file. For example, will there be a magic number
at the beginning of the file for easier error checking? Or where in the file do
we specify whether our code and data is in a 32-bit or 64-bit format? There are
other formats, but ELF is pretty good.</p>
<p>After you run this command, you should see a <code>multiboot_header.o</code> file in
the same directory. This is our ‘object file’, hence the <code>.o</code>. Don't let the
word ‘object’ confuse you. It has nothing to do with anything object oriented.
‘Object files’ are just binary code with some metadata in a particular format -
in our case ELF. Later, we’ll take this file and use it to build our OS.</p>
<h2>Summary</h2>
<p>Congratulations! This is the first step towards building an operating system.
We learned about the boot process, the GRUB bootloader, and the Multiboot
specification. We wrote a Multiboot-compliant header file in assembly code, and
used <code>nasm</code> to create an object file from it.</p>
<p>Next, we’ll write the actual code that prints “Hello world” to the screen.</p>
<h1>Hello, world!</h1>
<p>Now that we’ve got the headers out of the way, let’s do the traditional first
program: Hello, world!</p>
<h2>The smallest kernel</h2>
<p>Our hello world will be just <em>20</em> lines of assembly code. Let’s begin.
Open a file called <code>boot.asm</code> and put this in it:</p>
<pre><code class="language-x86asm">start:
    hlt
</code></pre>
<p>You’ve seen the <code>name:</code> form before: it’s a <em>label</em>. This lets us name a line
of code. We’ll call this label <code>start</code>, which is the traditional name.
GRUB will use this convention to know where to begin.</p>
<p>The <code>hlt</code> statement is our first bit of ‘real’ assembly. So far, we had just
been declaring data. This is actual, executable code. It’s short for ‘halt’.
In other words, it ends the program.</p>
<p>By giving this line a label, we can call it, sort of like a function. That’s what
GRUB does: “Call the function named <code>start</code>.” This function has just one
line: stop.</p>
<p>Unlike many other languages, you’ll notice that there’s no way to say if
this ‘function’ takes any arguments or not. We’ll talk more about that later.</p>
<p>This code won’t quite work on its own though. We need to do a little bit more
bookkeeping first. Here’s the next few lines:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    hlt
</code></pre>
<p>Three new bits of information. The first:</p>
<pre><code class="language-x86asm">global start
</code></pre>
<p>This says “I’m going to define a label <code>start</code>, and I want it to be available
outside of this file.” If we don’t say this, GRUB won’t know where to find its
definition. You can kind of think of it like a ‘public’ annotation in other
languages.</p>
<pre><code class="language-x86asm">section .text
</code></pre>
<p>We saw <code>section</code> briefly, but I told you we’d get to it later. The place where
we get to it is at the end of this chapter. For the moment, all you need to
know is this: code goes into a section named <code>.text</code>. Everything that comes
after the <code>section</code> line is in that section, until another <code>section</code> line.</p>
<pre><code class="language-x86asm">bits 32
</code></pre>
<p>GRUB will boot us into protected mode, aka 32-bit mode. So we have to specify
that directly. Our Hello World will only be in 32 bits. We’ll transition from
32-bit mode to 64-bit mode in the next chapter, but it’s a bit involved.
So let’s just stay in protected mode for now.</p>
<p>That’s it! We could theoretically stop here, but instead, let’s actually print
the “Hello world” text to the screen. We’ll start off with an ‘H’:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    hlt
</code></pre>
<p>This new line is the most complicated bit of assembly we’ve seen yet. There’s a
lot packed into this little line.</p>
<p>The first important bit is <code>mov</code>. This is short for <code>move</code>, and it sorta looks
like this:</p>
<pre><code class="language-text">mov size place, thing
</code></pre>
<p>Oh, <code>;</code> starts a comment, remember? So the <code>; H</code> is just for us. I put this
comment here because this line prints an <code>H</code> to the screen!</p>
<p>Yup, it does. Okay, so here’s why: <code>mov</code> copies <code>thing</code> into <code>place</code>. The amount
of stuff it copies is determined by <code>size</code>.</p>
<pre><code class="language-x86asm">;   size place      thing
;   |    |          |
;   V    V          V
mov word [0xb8000], 0x0248 ; H
</code></pre>
<p>“Copy one word: the number <code>0x248</code> to ... some place.</p>
<p>The place is a hexidecimal number, but has square brackets <code>[]</code> around it.
Those brackets are special. They mean “the address in memory located by this
number.” In other words, we’re copying the number <code>0x0248</code> into the specific
memory location <code>0xb8000</code>. That’s what this line does.</p>
<p>Why? Well, we’re using the screen as a “memory mapped” device. Specific
positions in memory correspond to certain positions on the screen. And
the position <code>0xb8000</code> is one of those positions: the upper-left corner of the
screen.</p>
<p>Now, we are copying <code>0x0248</code>. Why this number? Well, it’s in three parts:</p>
<pre><code class="language-text"> __ background color
/  __foreground color
| /
V V
0 2 48 &lt;- letter, in ASCII
</code></pre>
<p>We’ll start at the right. First, two numbers are the letter, in ASCII. <code>H</code> is
72 in ASCII, and 48 is 72 in hexidecimal: <code>(4 * 16) + 8 = 72</code>. So this will
write <code>H</code>.</p>
<p>The other two numbers are colors. There are 16 colors available, each with a
number. Here’s the table:</p>
<pre><code>| Value | Color          |
|-------|----------------|
| 0x0   | black          |
| 0x1   | blue           |
| 0x2   | green          |
| 0x3   | cyan           |
| 0x4   | red            |
| 0x5   | magenta        |
| 0x6   | brown          |
| 0x7   | gray           |
| 0x8   | dark gray      |
| 0x9   | bright blue    |
| 0xA   | bright green   |
| 0xB   | bright cyan    |
| 0xC   | bright red     |
| 0xD   | bright magenta |
| 0xE   | yellow         |
| 0xF   | white          |
</code></pre>
<p>So, <code>02</code> is a black background with a green foreground. Classic. Feel free to
change this up, use whatever combination of colors you want!</p>
<p>So this gives us a <code>H</code> in green, over black. Next letter: <code>e</code>.</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    hlt
</code></pre>
<p>Lower case <code>e</code> is <code>65</code> in ASCII, at least, in hexidecimal. And <code>02</code> is our same
color code. But you’ll notice that the memory location is different.</p>
<p>Okay, so we copied four hexidecimal digits into memory, right? For our <code>H</code>.
<code>0248</code>. A hexidecimal digit has sixteen values, so two of them are 32. Since we
need one word for the colors, and one word for the <code>H</code>, that’s two words.
Hence, if our first memory position is at <code>0</code>, the second letter will start at
<code>2</code>.</p>
<p>This math gets easier the more often you do it. And we won’t be doing <em>that</em> much
more of it. There is a lot of working with hex numbers in operating systems work,
so you’ll get better as we practice.</p>
<p>With this, you should be able to get the rest of Hello, World. Go ahead and try
if you want: each letter needs to bump the location twice, and you need to look
up the letter’s number in hex.</p>
<p>If you don’t want to bother with all that, here’s the final code:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    mov word [0xb8004], 0x026c ; l
    mov word [0xb8006], 0x026c ; l
    mov word [0xb8008], 0x026f ; o
    mov word [0xb800a], 0x022c ; ,
    mov word [0xb800c], 0x0220 ;
    mov word [0xb800e], 0x0277 ; w
    mov word [0xb8010], 0x026f ; o
    mov word [0xb8012], 0x0272 ; r
    mov word [0xb8014], 0x026c ; l
    mov word [0xb8016], 0x0264 ; d
    mov word [0xb8018], 0x0221 ; !
    hlt
</code></pre>
<p>Finally, now that we’ve got all of the code working, we can assemble our
<code>boot.asm</code> file with <code>nasm</code>, just like we did with the <code>multiboot_header.asm</code>
file:</p>
<pre><code class="language-bash">$ nasm -f elf64 boot.asm
</code></pre>
<p>This will produce a <code>boot.o</code> file. We’re almost ready to go!</p>
<h2>Linking it together</h2>
<p>Okay! So we have two different <code>.o</code> files: <code>multiboot_header.o</code> and <code>boot.o</code>.
But what we need is <em>one</em> file with both of them. Our OS doesn’t have the
ability to do anything yet, let alone load itself in two parts somehow. We just
want one big binary file.</p>
<p>Enter ‘linking’. If you haven’t worked in a compiled language before, you
probably haven’t had to deal with linking before. Linking is how we’ll turn
these two files into a single output: by linking them together.</p>
<p>Open up a file called <code>linker.ld</code>and put this in it:</p>
<pre><code class="language-text">ENTRY(start)

SECTIONS {
    . = 1M;

    .boot :
    {
        /* ensure that the multiboot header is at the beginning */
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }
}
</code></pre>
<p>This is a ‘linker script’. It controls how our linker will combine these
files into the final output. Let’s take it bit-by-bit:</p>
<pre><code class="language-text">ENTRY(start)
</code></pre>
<p>This sets the ‘entry point’ for this executable. In our case, we called our
entry point by the name people use: <code>start</code>. Remember? In <code>boot.asm</code>? Same
name here.</p>
<pre><code class="language-text">SECTIONS {
</code></pre>
<p>Okay! I’ve been promising you that we’d talk about sections. Everything inside
of these curly braces is a section. We annotated parts of our code with
sections earlier, and here, in this part of the linker script, we will describe
each section by name and where it goes in the resulting output.</p>
<pre><code class="language-text">    . = 1M;
</code></pre>
<p>This line means that we will start putting sections at the one megabyte mark.
This is the conventional place to put a kernel, at least to start. Below one
megabyte is all kinds of memory-mapped stuff. Remember the VGA stuff? It
wouldn’t work if we mapped our kernel’s code to that part of memory... garbage
on the screen!</p>
<pre><code class="language-text">    .boot :
</code></pre>
<p>This will create a section named <code>boot</code>. And inside of it...</p>
<pre><code class="language-text">        *(.multiboot_header)
</code></pre>
<p>... goes every section named <code>multiboot_header</code>. Remember how we defined that
section in <code>multiboot_header.asm</code>? It’ll be here, at the start of the <code>boot</code>
section. That’s what we need for GRUB to see it.</p>
<pre><code class="language-text">    .text :
</code></pre>
<p>Next, we define a <code>text</code> section. The <code>text</code> section is where you put code.
And inside of it...</p>
<pre><code class="language-text">        *(.text)
</code></pre>
<p>... goes every section named <code>.text</code>. See how this is working? The syntax is a
bit weird, but it’s not too bad.</p>
<p>That’s it for our script! We can then use <code>ld</code> to link all of this stuff
together:</p>
<pre><code class="language-bash">$ ld --nmagic --output=kernel.bin --script=linker.ld multiboot_header.o boot.o
</code></pre>
<p>By running this command, we do a few things:</p>
<pre><code class="language-text">--nmagic
</code></pre>
<p>TODO: https://github.com/intermezzOS/book/issues/30</p>
<pre><code class="language-text">--output=kernel.bin
</code></pre>
<p>This sets the name of our output file. In our case, that’s <code>kernel.bin</code>. We’ll be using
this file in the next step. It’s our whole kernel!</p>
<pre><code class="language-text">--script=linker.ld
</code></pre>
<p>This is the linker script we just made.</p>
<pre><code class="language-text">multiboot_header.o boot.o
</code></pre>
<p>Finally, we pass all the <code>.o</code> files we want to link together.</p>
<p>That’s it! We’ve now got our kernel in the <code>kernel.bin</code> file. Next, we’re going to
make an ISO out of it, so that we can load it up in QEMU.</p>
<h1>Making an ISO</h1>
<p>Now that we have our <code>kernel.bin</code>, the next step is to make an ISO. Remember
compact discs? Well, by making an ISO file, we can both test our Hello World
kernel in QEMU, as well as running it on actual hardware!</p>
<p>To do this, we’re going to use a GRUB tool called <code>grub-mkrescue</code>. We have to
create a certain structure of files on disk, run the tool, and we’ll get an
<code>os.iso</code> file at the end.</p>
<p>Doing so is not very much work, but we need to make the files in the right
places. First, we need to make three directories:</p>
<pre><code class="language-bash">$ mkdir -p isofiles/boot/grub
</code></pre>
<p>The <code>-p</code> flag to <code>mkdir</code> will make the directory we specify, as well as any
‘parent’ directories, hence the <code>p</code>. In other words, this will make an
<code>isofiles</code> directory, with a <code>boot</code> directory inside, and a <code>grub</code> directory
inside of that.</p>
<p>Next, create a <code>grub.cfg</code> file inside of that <code>isofiles/boot/grub</code> directory,
and put this in it:</p>
<pre><code class="language-text">set timeout=0
set default=0

menuentry &quot;intermezzOS&quot; {
    multiboot2 /boot/kernel.bin
    boot
}
</code></pre>
<p>This file configures GRUB. Let’s talk about the <code>menuentry</code> block first.
GRUB lets us load up multiple different operating systems, and it usually does
this by displaying a menu of OS choices to the user when the machine boots. Each
<code>menuentry</code> section corresponds to one of these. We give it a name, in this
case, <code>intermezzOS</code>, and then a little script to tell it what to do. First,
we use the <code>multiboot2</code> command to point at our kernel file. In this case,
that location is <code>/boot/kernel.bin</code>. Remember how we made a <code>boot</code> directory
inside of <code>isofiles</code>? Since we’re making the ISO out of the <code>isofiles</code> directory,
everything inside of it is at the root of our ISO. Hence <code>/boot</code>.</p>
<p>Let’s copy our <code>kernel.bin</code> file there now:</p>
<pre><code class="language-bash">$ cp kernel.bin isofiles/boot/
</code></pre>
<p>Finally, the <code>boot</code> command says “that’s all the configuration we need to do,
boot it up.“</p>
<p>But what about those <code>timeout</code> and <code>default</code> settings? Well, the <code>default</code> setting
controls which <code>menuentry</code> we want to be the default. The numbers start at zero,
and since we only have that one, we set it as the default. When GRUB starts, it
will wait for <code>timeout</code> seconds, and then choose the <code>default</code> option if the user
didn’t pick a different one. Since we only have one option here, we just set it to
zero, so it will start up right away.</p>
<p>The final layout should look like this:</p>
<pre><code class="language-text">isofiles/
└── boot
    ├── grub
    │   └── grub.cfg
    └── kernel.bin
</code></pre>
<p>Using <code>grub-mkrescue</code> is easy. We run this command:</p>
<pre><code class="language-bash">$ grub-mkrescue -o os.iso isofiles
</code></pre>
<p>The <code>-o</code> flag controls the <em>o</em>utput filename, which we choose to be <code>os.iso</code>.
And then we pass it the directory to make the ISO out of, which is the
<code>isofiles</code> directory we just set up.</p>
<p>After this, you have an <code>os.iso</code> file with our teeny kernel on it. You could
burn this to a USB stick or CD and run it on an actual computer if you wanted
to! But doing so would be really annoying during development. So in the next
setction, we’ll use an emulator, QEMU, to run the ISO file on our development
machine.</p>
<h1>Running in QEMU</h1>
<p>Let’s actually run our kernel! To do this, we’ll use QEMU, an emulator. Using
QEMU is fairly straightfoward:</p>
<pre><code class="language-bash">$ qemu-system-x86_64 -cdrom os.iso
</code></pre>
<p>Type it in, hit enter, and you should see Hello World!</p>
<p><img alt="hello world" class="center" src="assets/hello_world.png" /></p>
<p>If it shows up for you too, congrats! If not, something may have gone
wrong. Double check that you followed the examples <em>exactly</em>. Maybe
you missed something, or made a mistake while copying things down.</p>
<p>Note all of this other stuff behind the Hello World message: We didn’t
clear the screen, so everything from GRUB just stays as it is. We’ll
write a function to do that eventually...</p>
<p>Let’s talk about this command before we move on:</p>
<pre><code class="language-text">qemu-system-x86_64
</code></pre>
<p>We’re running the <code>x86_64</code> varient of QEMU. While we have a 32-bit kernel for
now, soon we’ll have a 64-bit one. And since things are backwards compatible,
this works just fine.</p>
<pre><code class="language-text">-cdrom os.iso
</code></pre>
<p>We’re going to start QEMU with a CD-ROM drive, and its contents are the
<code>os.iso</code> file we made.</p>
<p>That’s it! Here’s the thing, though: while that wasn’t <em>too</em> complicated, it
was a lot of steps. Each time we make a change, we have to go through all these
steps over again. In the next section, we’ll use Make to do all these steps for
us.</p>
<h1>Automation with Make</h1>
<p>Typing all of these commands out every time we want to build the project is
tiring and error-prone. It’s nice to be able to have a single command that
builds our entire project. To do this, we’ll use <code>make</code>. Make is a classic
bit of software that’s used for this purpose. At its core, <code>make</code> is fairly
simple:</p>
<ul>
<li>You create a file called <code>Makefile</code>.</li>
<li>In this file, you define <strong>rules</strong>. Rules are composed of three things:
<strong>targets</strong>, <strong>prerequisites</strong>, and <strong>commands</strong>.</li>
<li>Targets describe what you are trying to build.</li>
<li>Targets can depend on other targets being built before they can be built.
These are called ‘prerequisites’.</li>
<li>Commands describe what it takes to actually build the target.</li>
</ul>
<p>Let’s start off with a very straightforward rule. Specifically, the first step
that we did was to build the Multiboot header by running <code>nasm</code>. Let’s build a
<code>Makefile</code> that does this. Open a file called <code>Makefile</code> and put this in it:</p>
<pre><code class="language-make">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm
</code></pre>
<p>It’s <em>very</em> important that that <code>nasm</code> line uses a tab to indent. It can’t be
spaces. It has to be a tab. Yay legacy software!</p>
<p>Let’s try to run it before we talk about the details:</p>
<pre><code class="language-bash">$ make
nasm -f elf64 multiboot_header.asm
$
</code></pre>
<p>If you see this output, success! Let’s talk about this syntax:</p>
<pre><code class="language-text">target: prerequisites
        command
</code></pre>
<p>The bit before the colon is called a ‘target’. That’s the thing we’re trying to
build. In this case, we want to create the <code>multiboot_header.o</code> file, so we name
our target after that.</p>
<p>After the colon comes the ‘prerequisites’. This is a list of other targets that must
be built for this target to be built. In this case, building <code>multiboot_header.o</code>
requires that we have a <code>multiboot_header.s</code>. Because we have no rule describing how
to build this file, it existing is enough to satisfy the dependency.</p>
<p>Finally, on the next line, and indented by a tab, we have a ‘command’. This is the
shell command that you need to build the target.</p>
<p>Building <code>boot.o</code> is similar:</p>
<pre><code class="language-make">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm
</code></pre>
<p>Let’s try to build it:</p>
<pre><code class="language-bash">$ make
make: ‘multiboot_header.o’ is up to date.
$
</code></pre>
<p>Wait a minute, what? There’s two things going on here. The first is that <code>make</code> will build
the first target that you list by default. So a simple <code>make</code> will not build <code>boot.o</code>. To
build it, we can pass <code>make</code> the target name:</p>
<pre><code class="language-bash">$ make boot.o
nasm -f elf64 boot.asm
</code></pre>
<p>Okay, so that worked. But what about this ‘is up to date’ bit?</p>
<p>By defualt, <code>make</code> will keep track of the last time you built a particular
target, and check its last-modified-time against that time. If it hasn’t been
updated since it was built, then it won’t re-execute the build command. This is
a really powerful feature, especially as we grow. You don’t want to force the
entire project to re-build just because you edited one file; it’s nicer to only
re-build the bits that interact with it directly. A lot of the skill of <code>make</code>
is defining the right targets to make this work out nicely.</p>
<p>It would be nice if we could build both things with one command, but as it
turns out, our next target, <code>kernel.bin</code>, relies on both of these <code>.o</code> files,
so let’s write it first:</p>
<pre><code class="language-make">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>Let’s try building it:</p>
<pre><code class="language-bash">$ $ make kernel.bin
ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>Great! The <code>kernel.bin</code> target depends on <code>multiboot_header.o</code>, <code>boot.o</code>, and <code>linker.ld</code>. The
first two are the previous targets we defined, and <code>linker.ld</code> is a file on its own.</p>
<p>Let’s make <code>make</code> build the whole thing by default:</p>
<pre><code class="language-make">default: kernel.bin

multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>We can name targets whatever we want. In this case, <code>default</code> is a good
convention for the first rule, as it’s the default target. It relies on
the <code>kernel.bin</code> target, which means that we’ll build it, and as we previously
discussed, <code>kernel.bin</code> will build our two <code>.o</code>s.</p>
<p>Let’s try it out:</p>
<pre><code class="language-bash">$ make
make: Nothing to be done for ‘defualt’.
</code></pre>
<p>We haven’t edited our files, so everything is built. Let’s modify one. Open up
<code>multiboot_header.asm</code> in your editor, save it, and then run <code>make</code>:</p>
<pre><code class="language-bash">$ make
nasm -f elf64 multiboot_header.asm
ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>It re-built <code>multiboot_header.o</code>, and then <code>kernel.bin</code>. But it didn’t rebuild
<code>boot.o</code>, as we didn’t modify it at all.</p>
<p>Let’s add a new rule to build our iso. Rather than show the entire <code>Makefile</code>, I’m
going to start showing you what’s changed. First, we have to update our <code>default</code>
target, and then we have to write the new one:</p>
<pre><code class="language-make">default: isofiles

isofiles: kernel.bin grub.cfg
        mkdir -p isofiles/boot/grub
        cp grub.cfg isofiles/boot/grub
        cp kernel.bin isofiles/boot/
</code></pre>
<p>This is our first multi-command rule. <code>make</code> will execute all of the commands
that you list. In this case, to build the ISO, we need to create our <code>isofiles</code>
directory, and then copy <code>grub.cfg</code> and <code>kernel.bin</code> into the right place
inside of it.</p>
<p>Let’s try:</p>
<pre><code class="language-bash">$ make
mkdir -p isofiles/boot/grub
cp grub.cfg isofiles/boot/grub
cp kernel.bin isofiles/boot/
</code></pre>
<p>We’ve prepared ourselves to create the ISO. Let’s add a new rule to build <code>os.iso</code>:</p>
<pre><code class="language-make">defualt: os.iso

os.iso: isofiles
        grub-mkrescue -o os.iso isofiles
</code></pre>
<p>Building the ISO requires that the <code>isofiles</code> directory is created and
up-to-date.</p>
<p>Sometimes, it’s nice to add targets which describe a semantic. In this case, building
the <code>os.iso</code> target is the same as building the project. So let’s say so:</p>
<pre><code class="language-make">defualt: build

build: os.iso
</code></pre>
<p>The defualt action is to build the project, and to build the project, we need to build
<code>os.iso</code>. But what about running it? Let’s add a rule for that:</p>
<pre><code class="language-make">defualt: run

run: os.iso
        qemu-system-x86_64 -cdrom os.iso
</code></pre>
<p>You can choose the default here: do you want the defualt to be build, or run? Here’s what
each looks like:</p>
<pre><code class="language-bash">$ make     # build is the default
$ make run
</code></pre>
<p>or</p>
<pre><code class="language-bash">$ make       # run is the default
$ make build
</code></pre>
<p>I prefer to make <code>run</code> the default.</p>
<p>Finally, there’s another useful common rule: <code>clean</code>. The <code>clean</code> rule should remove all
of the generated files, and allow us to do a full re-build. As such it’s a bunch of <code>rm</code>
statements:</p>
<pre><code class="language-make">.PHONY: clean
clean: 
        rm -f multiboot_header.o
        rm -f boot.o
        rm -f kernel.bin
        rm -rf isofiles
        rm -f os.iso
</code></pre>
<p>What about that <code>.PHONY</code>? It’s a special, built-in target. Any dependencies of a <code>.PHONY</code>
target will always be considered fresh; in other words, running <code>make clean</code> will skip
checking if it’s been done already and just execute. In this case, this is what we want;
we want to nuke all the files, we don’t care when they were modified.</p>
<p>Here’s our final <code>Makefile</code>:</p>
<pre><code class="language-make">default: run

.PHONY: clean

multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o

isofiles: kernel.bin grub.cfg
        mkdir -p isofiles/boot/grub
        cp grub.cfg isofiles/boot/grub
        cp kernel.bin isofiles/boot/

os.iso: isofiles
        grub-mkrescue -o os.iso isofiles

build: os.iso

run: os.iso
        qemu-system-x86_64 -cdrom os.iso

clean: 
        rm -f multiboot_header.o
        rm -f boot.o
        rm -f kernel.bin
        rm -rf isofiles
        rm -f os.iso
</code></pre>
<p>You'll notice that there is a fair amount of repetition here. At first, that's
pretty okay: make can be a bit hard to understand, and while it has features
that let you de-duplicate things, they can also get unreadable really fast.</p>
<h2>Creating a build subdirectory</h2>
<p>Here's one example of a tweak we can do: <code>nasm</code> supports a <code>-o</code> flag, which
controls the name of the output file. We can use this to build <em>everything</em> in
a <code>build</code> subdirectory. This is nice for a number of reasons, but one of the
simplest is that all of our generated files will go in a single directory,
which means that it’s much easier to keep track of them: they’ll all be in one
place.</p>
<p>Let’s make some changes: More specifically, three of them:</p>
<pre><code class="language-make">build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o
</code></pre>
<p>The first one is the name of the rule. We have to add a <code>build/</code> in front of
the filename. This is because we’re going to be putting this file in that
directory now.</p>
<p>Second, we added another line: <code>mkdir</code>. We used <code>-p</code> to make directories
before, but in this case, the purpose of the flag is to not throw an error
if the directory already exists. We need to try to make this directory
when we build so that we can put our <code>.o</code> file in it!</p>
<p>Finally, we add the <code>-o</code> flag to <code>nasm</code>. This will create our output file in
that <code>build</code> directory, rather than in the current one.</p>
<p>With that, we’re ready to modify <code>boot.o</code> as well:</p>
<pre><code class="language-make">build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o
</code></pre>
<p>These changes are the same, just with <code>boot</code> instead of <code>multiboot_header</code>.</p>
<p>Next up: <code>kernel.bin</code>:</p>
<pre><code class="language-make">build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o
</code></pre>
<p>We append <code>build</code> in no fewer than <em>six</em> places. Whew! At least it’s
straightforward.</p>
<pre><code class="language-make">build/isofiles: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/
</code></pre>
<p>In a similar fashion, we prefix all the things with <code>build</code>.</p>
<pre><code class="language-make">build/os.iso: build/isofiles
        grub-mkrescue -o build/os.iso build/isofiles
</code></pre>
<p>Seeing a pattern yet? More prefixing.</p>
<pre><code class="language-make">run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso
</code></pre>
<p>... and here as well.</p>
<pre><code class="language-make">clean: 
        rm -rf build
</code></pre>
<p>Now some payoff! To get rid of our generated files, all we have to do is <code>rm</code>
our <code>build</code> directory. Much easier.</p>
<p>Here’s our final version:</p>
<pre><code class="language-make">default: run

.PHONY: clean

build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o

build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o

build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o

build/isofiles: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/

build/os.iso: build/isofiles
        grub-mkrescue -o build/os.iso build/isofiles

run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso

clean: 
        rm -rf build
</code></pre>
<p>We can go farther, and eventually, we will. But this is good enough for now.
Like I said, there’s a fine balance between keeping it DRY and making it
non-understandable.</p>
<p>Luckily, we’ll only be using Make for these assembly files. Rust has its own
build tool, Cargo, that we’ll integrate with Make. It’s a lot easier to use.</p>
<h1>Source Control with Git</h1>
<h1>Transitioning to Long Mode</h1>
<h1>A Rust kmain()</h1>
<h1>A simple VGA driver</h1>
<h1>Keyboard input</h1>
<p>COMING SOON</p>
<h1>Numeral Systems</h1>
<p>In math we use a particular <strong>numeral system</strong> to denote a particular number. A
numeral system is defined by the particular symbols it uses to convey numbers.</p>
<p>Below we'll examine three numeral systems: decimal, binary and hexadecimal.</p>
<h2>Decimal System</h2>
<p>The numeral system you're probably most familiar with is the <strong>decimal system</strong>.
The symbols (or &quot;digits&quot;) used in decimal are: <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>,
<code>6</code>, <code>7</code>, <code>8</code>, and <code>9</code>.</p>
<p>Decimal gets its name from the amount of unique symbols it uses to convey
numbers: ten. It makes sense that we would gravitate to a system with ten
unique symbols. After all, we typically have ten fingers (and ten toes).</p>
<p>The amount of unique symbols a numeral system uses is known as the &quot;base&quot; of that system
(and is less often called a &quot;radix&quot;).</p>
<p>Decimal is also a &quot;positional&quot; numeral system. Once we run out of symbols, we
begin a new &quot;order of magnitude&quot; over with the same symbols. For example, after
<code>9</code> comes <code>10</code>. We recycle the <code>1</code> and <code>0</code> symbols to express that we've cycled
through the number <code>1</code> times. When we reach <code>20</code>, we want to say we've cycled
though <code>2</code> times. We start new cycles at a regular interval - every time we've
cycled through all the symbols of the digit furthest to the left.</p>
<p>If you're familiar with Roman numerals, you know that that system did not work
that way. &quot;Orders of magnitude&quot; don't start and stop at regular intervals.</p>
<h3>Let's Count</h3>
<p>At the risk of taking things too slow, let's count in decimal the number of <code>|</code>s here:</p>
<p><code>||||||||||||</code></p>
<p>Let's begin with zero and go higher:</p>
<p><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code> ...</p>
<p>Ok we're at nine, and we've run out of symbols. No worries. We add a <code>1</code> to the
beginning to say we've already gone through one cycle of numbers, and we start
over.</p>
<p>... <code>10</code>, <code>11</code>, <code>12</code></p>
<p>Sorry if that was a bit too easy. You're probably pretty good with the decimal
system already so this wasn't too big of a challenge. But we'll do the same
exercise with other numeral systems to get a better feel for them.</p>
<h3>Let's Use Math</h3>
<p>We can sumarize what we just said with a math formula:</p>
<p>\[ 1 \cdot 10^1 + 2 \cdot 10^0 = 12 \]</p>
<p>Here we've written out that we've cycled completely through the numbers once
and then gotten through two symbols of the next cycle.</p>
<p>The value <code>120</code> has a <code>0</code> at position zero, a <code>2</code> at position one and a <code>1</code> at position two.</p>
<ul>
<li>
<p>The <code>1</code> at position two means you have counted &quot;one&quot; times &quot;ten&quot; (a.k.a the base)
times all the digits (a.k.a the base) or
\[ 1\cdot base \cdot base = 1 \cdot base^2 = 1 \cdot 10^2 = 100 \]
When writing it as a power of the base, we can see the relation between the
position of the digit and the power of the base.</p>
</li>
<li>
<p>The <code>2</code> at position one means you have counted <em>two times all the digits (a.k.a the base)</em> or
\[ 2 \cdot base = 2 \cdot base^1 =  2 * 10^1 = 20 \]</p>
</li>
<li>
<p>The <code>0</code> at position zero means you have counted <em>zero elements</em> or
\[ 0 = 0 \cdot base^0 = 0 \cdot 10^0 = 0 \cdot 1 = 0 \]</p>
</li>
</ul>
<p>When we add all that up we obtain</p>
<p>\[ 1 \cdot base^2 + 2 \cdot base^1 + 0 \cdot base^0 = 1 \cdot 10^2 +  2 \cdot 10^1 + 0 \cdot 10^0 = 100 + 20 + 0 = 120 \]</p>
<p>Congrats! You've successfully converted a decimal value back into decimal - a
feat that probably seems utterly useless but will come in very handy when we
want to convert from some other numeral system to decimal.</p>
<p>Now we'll examine two new numeral systems. The are positional just like decimal, but
have different bases. We'll examine <strong>binary</strong> with a base of two, and <strong>hexadecimal</strong>
with a base of sixteen.</p>
<h2>Binary system</h2>
<p>Unlike decimal's base of ten, binary has a base of two. Meaning we only have two
symbols to work with to represent all the numbers: <code>0</code>, <code>1</code>. Say
goodbye to <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, and <code>9</code>. We can't use them.</p>
<p>So when we have the binary number <code>10</code> we don't have the number ten. What we've really
done is counted <em>once trough all the digits of the system</em> <code>0</code>, <code>1</code> and
started again. So we have the number two.</p>
<h3>Let's Count</h3>
<p>Let's count <code>|</code> again, but this time in binary:</p>
<p><code>|||||||</code></p>
<p>If we were counting in decimal we would use the symbol <code>7</code> to refer to this
number. Let's start at zero:</p>
<p><code>0</code>, <code>1</code> ...</p>
<p>Hopefully you weren't tempted to go to <code>2</code> next! That's right, we've already
made a full round trip, so let's start over.</p>
<p>... <code>10</code>, <code>11</code>, <code>100</code>, <code>101</code>, <code>110</code>, <code>111</code></p>
<p>We've successfully counted to the number seven using binary!</p>
<h3>Let's Use Math</h3>
<p>The binary value <code>100</code> means we have counted <em>one times two (a.k.a the base) times
through all the digits (a.k.a. the base)</em>, which would equal to <code>4</code> in decimal.</p>
<p>\[1 \cdot base^2 + 0 \cdot base^1 + 0 \cdot base^0 = 1 \cdot 2^2 + 0 \cdot 2^1 + 0 \cdot 2^0 = 4 \]</p>
<p>Let's do one more, the binary value <code>1010</code> means we have counted <em>one times two
(a.k.a the base) times two (a.k.a the base) times two (a.k.a the base) digits</em>
and <em>one times two (a.k.a the base) times two (a.k.a the base) digits</em>.</p>
<p>\[ 1 \cdot base^3 + 0 \cdot base ^2 + 1 \cdot base^1 + 0 \cdot base^0 = 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0 = 8 + 2 = 10\]</p>
<p>Hurray! We've successfully converted binary to decimal!</p>
<h2>Hexadecimal System</h2>
<p>And now we meet hexadecimal with a base of sixteen. Before we begin we have to answer the
question of how we represent sixteen unique digits when we're used to representing only ten.</p>
<p>To represent the digits after <code>9</code> until a new cycle begins we'll use the letters
<code>a</code> through <code>f</code>. This is arbitrary and we could have chosen any other symbol really.
But then again it's all arbitrary. We could, for example, use the symbol <code>}</code> to represent
one, but we chose <code>1</code> instead.</p>
<p>So <code>a</code> in hexadecimal is equivalent to <code>10</code> in decimal, <code>b</code> equal to <code>11</code>, etc.</p>
<p>The value <code>10</code> does exist in hexadecimal. It means, once again, we have counted
<em>through all the digits of the system once</em> and are starting the cycle again.
However, instead of it being ten, it's sixteen. Another way of thinking about
this is <code>10</code> in hexadecimal is equal to <code>16</code> in decimal.</p>
<h3>Let's Count</h3>
<p>Once again, let's count <code>|</code>s but this time using hexadecimal notation:</p>
<p><code>||||||||||||||||||||</code></p>
<p>If we were using decimal we would use the symbol <code>20</code> to refer to this number.
Let's start again at zero:</p>
<p><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code> ...</p>
<p>Don't be tempted to do the decimal thing and use <code>10</code>!</p>
<p>... <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>, <code>10</code>, <code>11</code>, <code>12</code>, <code>13</code>, <code>14</code></p>
<p>Congrats! You've counted to twenty in hexadecimal!</p>
<h3>Let's Use Math</h3>
<p>Let's do the math thing one more time with an exotic hexadecimal value: <code>3e8</code>.
This value means we have counted <em>three times sixteen (a.k.a the base) times all the
digits of the system (a.k.a the base)</em> and <em><code>e</code> times, which is equal to 14 in decimal,
all digits (a.k.a the base)</em> and <em>8 remaining elements</em>.</p>
<p>\[ 3 \cdot base^2 + e \cdot base^1 + 8 \cdot base^0 = 3 \cdot 16^2 + 14 \cdot 16^1 + 8 \cdot 16^0 = 768 + 224 + 8 = 1000 \]</p>
<h2>Converting From Decimal to Another Base</h2>
<p>Until now, we have only converted values from a numeral system with a specific base
to the decimal system. But what if we want to do the opposite?</p>
<p>For this we are going to use the <strong>divison</strong> and <strong>remainders</strong></p>
<p>Let's say we have the value <code>2344</code> and want to convert it into hexadecimal.
We are going to divide the value by the base we want to convert to. The remainder
of this operation will be our first digit (at position zero) and we are going to
repeat this operation with the result of the (integer) division.</p>
<p>\[ \begin{array}
{lcr} 16 &amp; | &amp; 2344
\\ &amp;&amp; 146 &amp; rem &amp; 8
\\ &amp;&amp; 9 &amp; rem &amp; 2
\\ &amp;&amp; 0 &amp; rem &amp; 9
\end{array}
\]</p>
<p>Remember the first remainder is the digit at the first position, position zero!
So the converted number reads from bottom up: <code>928</code>. We can double check that this
is correct by converting the hexadecimal result back into decimal using the power rule.</p>
<p>\[ 9 \cdot 16^2 + 2 \cdot 16^1 + 8 \cdot 16^0 = 2344 \]</p>
<p>Let's do one more hexadecimal number before we try some binary numbers.
The value we are going to convert from decimal to hexadecimal is <code>43981</code>.</p>
<p>\[ \begin{array}
{lcr} 16 &amp; | &amp; 43981
\\ &amp;&amp; 2748 &amp; rem &amp; 13 = d
\\ &amp;&amp; 171 &amp; rem &amp; 12 = c
\\ &amp;&amp; 10 &amp; rem &amp; 11 = b
\\ &amp;&amp; 0 &amp; rem &amp; 10 = a
\end{array}
\]</p>
<p>The decimal value <code>43981</code> corresponds thus to the hexadecimal value <code>abcd</code></p>
<p>Let's try the same for binary numbers now, if we want to convert the decimal value
<code>41</code> to binary:</p>
<p>\[ \begin{array}
{lcr} 2 &amp; | &amp; 41
\\ &amp;&amp; 20 &amp; rem &amp; 1
\\ &amp;&amp; 10 &amp; rem &amp; 0
\\ &amp;&amp; 5 &amp; rem &amp; 0
\\ &amp;&amp; 2 &amp; rem &amp; 1
\\ &amp;&amp; 1 &amp; rem &amp; 0
\\ &amp;&amp; 0 &amp; rem &amp; 1
\end{array}
\]</p>
<p>We get the binary number <code>101001</code>, let's check:</p>
<p>\[ 1 \cdot 2^5 + 0 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 41 \]</p>
<p>Fantastic, it worked once again!</p>
<h2>Conclusion</h2>
<p>In this chapter we have learned there were many numeral systems beside the decimal
system we use in our every day life. We've seen why the hexadecimal system uses the
letters <code>a</code> through <code>f</code> and finally we have learned how to convert back and forth
between any numeral system and the decimal system.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
