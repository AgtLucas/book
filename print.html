<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="what.html"><strong>1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong>1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong>1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong>1.4.</strong> What tools will we use?</a></li></ul></li><li><a href="boot-to-kmain.html"><strong>2.</strong> Boot -> kmain()</a></li><li><a href="hello-world.html"><strong>3.</strong> Hello, world!</a></li><li><a href="keyboard-input.html"><strong>4.</strong> Keyboard input</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">intermezzOS</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1 class="center">intermezzOS</h1>
<p><img class="center" src="rhizome.jpg" alt="rhizome" /></p>
<p class="center">An operating system for learning</p>
<h2>Preface</h2>
<p>This book describes the intermezzOS project. intermezzOS is a hobby operating
system, specifically targeted at showing beginners how to get into operating
systems development. Rather than describe some sort of final OS, it instead
proceeds in a tutorial-like fashion, allowing you to implement intermezzOS
yourself, alongside the book.</p>
<p>The book assumes that you have programmed in some language before, but not any
particular one. In fact, people who have not done low-level programming before
are a specific target of this book; I’ll be explaining a lot of things that
other resources will just assume that you know.</p>
<p>intermezzOS is implemented in <a href="https://www.rust-lang.org/">Rust</a>, and some
assembly code. We’ll try to explain Rust along the way, but may refer you to
its documentation when things get tricky. This book isn’t <em>really</em> about
learning Rust, but you might accidentally along the way.</p>
<p>You can find all of this stuff <a href="https://github.com/intermezzOS/">on GitHub</a>.
This book is in the <code>book</code> repository, the kernel is in <code>kernel</code>, and the
website is there, too. Feel free to open issues on the <a href="https://github.com/intermezzOS/rfcs">RFCs
repo</a> if you want to discuss things
in a general sense, and send bug reports and PRs to the appropriate repos
if you’d like to help with a particular component.</p>
<h2>The Story</h2>
<p>A long time ago, in college, my friends and I were working on a hobby operating
system, <a href="http://xomb.org">XOmB</a>. It was... tough. Frankly, while I learned a
lot, I was a pretty minor contributor. I got frustrated too easily. One day, I
found Ruby, and I was pretty much done with low-level programming. I had done
it most of my life, and I was bored. Bored, and sick of dealing with core
dumps.</p>
<p>Those details aren’t that important. What is important is that over the years,
I’ve always wanted to get back into this stuff. But the problem is this: there
are a lot of people who do hobby operating system work, but... I don’t like
their attitudes.</p>
<p>You see, a lot of people see low-level programming as some kind of superior,
only-for-the-smartest kind of thing. They have a puritanical world-view: I
suffered to learn this, so you too must suffer, to build character. I think
that’s short sighted. Low level programming <em>is</em> difficult to get into, but
that says more about the teachers’ faults than the students’.</p>
<p>Anyway, as my professional life has moved back towards the low level, I’ve been
thinking about this topic a lot again. That’s when I found an awesome link:
<a href="http://os.phil-opp.com/multiboot-kernel.html">Writing an OS in Rust by Philipp Oppermann</a>. I cannot speak enough
about how awesome Phil’s tutorial is; it single-handedly inspired me to get
back into operating systems.</p>
<p>The big difference with Phil’s tutorial is that it doesn’t treat you as being
stupid for not knowing ‘the basics’. It doesn’t say “spend hours debugging this
thing, because I did.” It doesn’t insult you for being new. It just explains
the basics of a kernel.</p>
<p>It’s amazing how much a little bit of a framing can completely change the way
you see something. When the examples I found were all about how you have to be
an amazing rockstar ninja and we won’t give you all the code because you suck
if you can’t figure it out, I hated this stuff. When it was kind,
understanding, and helpful, I couldn’t get enough.</p>
<p>Once I got to a certain part in Phil’s tutorial, I started implementing stuff
myself. A lot of the initial code here is going to be similar to Phil’s.
But I’m going to write about it anyway. There’s a good reason for that:</p>
<blockquote>
<p>Writing is nature’s way of showing us how sloppy our thinking is.</p>
<ul>
<li>Leslie Lamport</li>
</ul>
</blockquote>
<p>By re-explaining things in my own words, I hope to understand it even better.
This is just a perpetual theme with me: I like teaching because it helps me
learn. I like writing because it helps me understand.</p>
<p>The first section of the book is going to be clear about where we’re following
Phil, and where we break off and go into our own little world. After the start,
things will end up diverging.</p>
<p>Furthermore, I will not commit to any kind of schedule for this project. It’s
going to be in my spare time, and I’m learning a lot of this as I go, too.</p>
<h2>The Name</h2>
<blockquote>
<p>The nomad has a territory; he follows customary paths; he goes from one point
to another; he is not ignorant of points (water points, dwelling points,
assembly points, etc.). But the question is what in nomad life is a principle
and what is only a consequence. To begin with, although the points determine
paths, they are strictly subordinated to the paths they determine, the
reverse happens with the sedentary. The water point is reached only in order
to be left behind; every point is a relay and exists only as a relay. A path
is always between two points, but the in-between has taken on all the
consistency and enjoys both an autonomy and a direction of its own. The life
of the nomad is the intermezzo.</p>
<p>Deleuze and Guattari, “A Thousand Plateaus”, p380</p>
</blockquote>
<p>If you’re not into particular kinds of philosophy, this quote won’t mean a lot.
Let’s look at the dictionary definition:</p>
<blockquote>
<p>An intermezzo, in the most general sense, is a composition which fits between
other musical or dramatic entities, such as acts of a play or movements of a
larger musical work.</p>
<p><a href="https://en.wikipedia.org/wiki/Intermezzo">https://en.wikipedia.org/wiki/Intermezzo</a></p>
</blockquote>
<p>I want this project to be about learning. Learning is often referred to as a
journey. You start off in ignorance, and end in knowledge. In other words,
‘learning’ is that part in the middle, the in-between state.</p>
<p>The tricky thing about learning is, you never stop learning. Once you learn
something, there’s something new to learn, and you’re on a journey again.</p>
<p>If you want to learn a lot, then you’ll find yourself perpetually in the
middle.</p>
<p>There is another sense by which this name makes sense: as we’ll learn in the
beginning of the book, operating systems are largely about abstractions. And
abstractions are themselves ‘in the middle’, between what they’re abstracting
and who they are abstracting it for.</p>
<h2>Principles</h2>
<p>Here are the guiding principles of intermezzOS:</p>
<ul>
<li>We’re all actual people. Please treat each other as such.</li>
<li>We’re all here to learn. Let’s help each other learn, rather than being some
kind of vanguard of knowledge.</li>
<li>The only thing that matters about your language background is the amount you
may have to learn.</li>
<li>Everything must be documented, or it’s not done.</li>
</ul>
<p>And of course, everything related to this project is under the <a href="http://intermezzos.github.io/code-of-conduct.html">Code of
Conduct</a>.</p>
<h1>Background</h1>
<p>Before we get going, we should probably have some idea of where we’re headed.</p>
<h1>What is an OS?</h1>
<p>It’s actually kind of difficult to define what an operating system is. There
are a lot of different kinds of operating systems, and they all do different
kinds of things.</p>
<p>There are some shared goals, however. Let’s try this out as a working
definition:</p>
<blockquote>
<p>An operating system is a program that provides a platform for other
programs. It provides two things to these programs: abstractions and
isolation.</p>
</blockquote>
<p>This is good enough for now. Let’s consider this a test for inclusion,
but not exclusion. In other words, things that fit this definition
<em>are</em> operating systems, but things that don’t may or may not be,
we don’t quite know.</p>
<h2>Creating abstractions</h2>
<p>There are many reasons to create a platform for other programs, but a
common one for operating systems is to abstract over hardware.</p>
<p>Consider a program, running on some hardware:</p>
<p><img alt="program on hardware" class="center" src="assets/program_hardware.png" /></p>
<p>This program will need to know <em>exactly</em> about what kind of hardware exists.
If you want to run it on a different computer, it will have to know exactly
about that computer too. And if you want to write a second program, you’ll
have to re-write all of that code.</p>
<blockquote>
<p>All problems in computer science can be solved by another level of
indirection.</p>
<ul>
<li>David Wheeler</li>
</ul>
</blockquote>
<p>To solve this problem, we can introduce an abstraction:</p>
<p><img alt="program on os on hardware" class="center" src="assets/program_os_hardware.png" /></p>
<p>Now, the operating system can handle the details of the hardware, and provide
an API for it. A program can be written for that operating system’s API, and
can then run on any hardware that the operating system supports.</p>
<p>At some point, though, we developed many operating systems. Since operating
systems are platforms, most people pick one and have only that one on their
computer. So now we have a problem that looks the same, but is a bit
different: our program is now specific to an OS, rather than specific to
a particular bit of hardware.</p>
<p>To solve this, some programming languages have a ‘virtual machine.’ This
was a bit selling point of Java, for example: the Java Virtual Machine.
The idea here is that we create a <em>virtual</em> machine on top of the <em>real</em>
machine.</p>
<p><img alt="program on vm " class="center" src="assets/program_vm_os_hardware.png" /></p>
<p>Now, you write programs for the Java Virtual Machine, which is then ported
to each operating system, which is then ported to all the hardware. Whew!</p>
<p>This, of course, leads to the collary to the previous maxim:</p>
<blockquote>
<p>...except for the problem of too many layers of indirection.</p>
<ul>
<li>Kevlin Henney</li>
</ul>
</blockquote>
<p>We now have a pattern:</p>
<ul>
<li>I have <code>A</code>.</li>
<li><code>A</code> is written explicitly for <code>X</code>...</li>
<li>... but I want to support <code>X</code> and <code>Y</code>,</li>
<li>so I put abstraction <code>B</code> in the middle.</li>
</ul>
<p>We will see this pattern over and over again. Hence ‘intermezzo’: abstractions
are always in the middle.</p>
<h2>Isolation</h2>
<p>Many of the abstractions provided are, as we discussed, abstractions over
hardware. And hardware often has a pretty serious restriction: only one
program can access the hardware at a time. So if our operating system is going
to be able to run multiple programs, which is a common feature of many
operating systems, we’ll also need to make sure that multiple programs cannot
access hardware at the same time.</p>
<p>This really applies to more than just hardware though: once we have two
programs, it would not be ideal to let them mess with each other. Consider any
sort of program that deals with your password: if programs could mess with each
other’s memory and code, then a program could trivially steal your password
from another program!</p>
<p>This is just one symptom of a general problem. It’s much better to isolate
programs from each other, for a number of different reasons. For now, we’ll
just consider isolation as one of our important jobs, as OS authors.</p>
<h3>Wait a minute...</h3>
<p>Here’s a question for you to ponder: if we didn’t provide isolation, isn’t that
just a poor abstraction? In other words, if we had an abstraction where we
could interact with other things being abstracted... isn’t that just a bad job
of doing the abstraction? And in that sense, is the only thing an operating
system does abstraction? Is the only thing everything does abstraction?</p>
<p>I don’t have answers for you. If you figure it out, let me know...</p>
<h1>What kinds of OS are there?</h1>
<p>Okay, so here’s the thing: operating systems are made up of a <em>lot</em> of
components. The core component is called a ‘kernel’. So, as OS developers, when
we categorize operating systems, we tend to categorize them by what kinds of
kernel they have. At the start, our ‘operating system’ will be just the kernel,
and so we’ll tend to focus on kernels for the first part of our journey.</p>
<p>The non-kernel bits of an operating system are called a ‘userland’. It’s where
the users live. This is also while you’ll hear some people say, “It’s
GNU/Linux, not Linux.” That’s because virtually all Linux distributions today
use a Linux kernel + a GNU userland. So the GNU folks are a bit annoyed that
the kernel gets all the credit. By the same token, a lot of people say ‘the
kernel’ when they mean ‘the Linux kernel.’ This gets an entirely different set
of people mad.</p>
<p>Sometimes, it just seems like everything makes everyone mad.</p>
<p>Anyway...</p>
<p>The way that we categorize different kernels largely comes down to “what is in
the kernel and what is in userspace.” Upon reading this, you might then think
the easiest kind of kernel to write is the smallest, where everything is in
userspace, but... that’s not actually true. Or at least, it’s not clear that
it’s true.</p>
<h2>Monolithic kernels</h2>
<p>First, we have ‘monolithic kernels’. ‘Mono’ meaning ‘one’. One big ‘ol kernel.
Everything that we need, the kernel has it all. A massive, towering achievement
of what we have accomplished.</p>
<p>Most real-world kernels are monolithic kernels, or at least, pretend to be.
Don’t worry about it. Linux, for example, is a monolithic kernel.</p>
<h2>Microkernels</h2>
<p>Microkernels are, well, micro. Smaller. The idea is this: if everything is in
the kernel, and something crashes, well, the whole ship is going down. Not
good. So there’s a small core kernel, and then there are components which
communicate with each other to get their job done.</p>
<p>This is a good idea in theory, but historically, microkernels have had issues.
All that communication has overhead, which makes them slower. Various things
have been done to try to mitigate this problem.</p>
<p>Mach, the kernel that Mac OS X uses, is a microkernel. Well, sort of. It ended
up being one, but Mac OS X uses a version of Mach from before that work was
done... so it’s a bit blurry.</p>
<p>GNU Hurd is a microkernel. It’s also kind of a running joke amongst kernel
people. It’s... a long story. Let’s just say that it’s been in development
since 1990. You see, once Linux happened, the need for Hurd was significantly
less, since a free software kernel now existed, and so it’s kind of languished.
There are people still working on it though! We may see a real release someday.</p>
<p>Don’t worry, Hurd will still be more successful than intermezzOS, I’d bet. If
you’re writing kernels for the glory, well, I’ve got some bad news. The vast
majority of kernels, like the vast majority of programs, have been relegated
to the dustbin of history. Don’t have the hubris to assume yours is different.
Life will serve you up some humble pie right quick.</p>
<h2>Exokernels</h2>
<p>What’s smaller than a microkernel? An exokernel, of course! An exokernel tries
to only do one thing: securely multiplex hardware. Everything that’s not
directly that lives in user space.</p>
<p>Exokernels are really interesting, but haven’t really made it outside of
university papers on exokernels. The hobby OS I worked on in college was an
exokernel.</p>
<p>There isn’t much to exokernels, so there’s not a lot to say about them.</p>
<h2>Unikernels</h2>
<p>Unikernels are kind of like exokernels, but with a fresh paint job and a
Twitter account. Okay, that’s a bit too glib. Unikernels are a major source
of excitement these days. Here’s the idea: an operating system that only
runs one program.</p>
<p>We haven’t really talked enough about the features of operating systems
generally to really discuss more about unikernels and why they matter, and
this isn’t a book about them, so more detail is going to have to have to
wait for another day.</p>
<h1>What kind are we making?</h1>
<p>So, given all these kinds of operating systems, what kind are we making?</p>
<p>The answer is “it doesn’t even matter at first.” There’s some commonality in
almost all of these styles of operating systems, and we have to get all that
done before we even make those decisions.</p>
<p>Secondly, we could waste a <em>lot</em> of time trying to design our perfect OS. And
then never actually build it. Remember, the goal here is <em>to learn</em>, not <em>to
make the best OS that ever existed</em>. So really, what it ends up looking like
just doesn’t really matter at all. Most hobby operating system projects die
quite young.</p>
<p>Let’s focus on the <em>doing</em>, and the less on the categorization, planning, and
being. A nice thing about operating systems is that there’s a lot of freedom of
direction. To tie it back into the example earlier, Phil’s tutorial starts
going into memory-management after getting printing to the screen going. We’ll
be going into keyboards first instead. There are, of course, some dependencies,
but there’s also a lot of freedom.</p>
<h1>What tools will we use?</h1>
<p>Before we can make a kernel, we need to figure out the tools we’re going to
use. The first question, of course, is what programming language?</p>
<p>In our case, we’re going to use two. The first one is the language that
<em>every</em> kernel must use: assembly language.</p>
<h2>Assembly</h2>
<p>Assembly language looks like this:</p>
<pre><code class="language-asm">section .data
global _start

_start:
    mov rax, 0
loop:
    add rax, 1
    cmp rax, 10
    jne loop

    mov rbx, rax
    mov rax, 1
    int 80h
</code></pre>
<p>This is a little program in assembly language. We can run it like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 lol.asm # assemble into lol.o
$ ld lol.o              # link into a.out
$ ./a.out               # run it
$ echo $?               # print out the exit code
10
$
</code></pre>
<p>You can write entire kernels in assembly if you want to. It’s not as bad as it
may sound. At the very beginning, we will <em>have</em> to use assembly. But not very
much. It takes about 100 lines total, to start. Completely manageable.</p>
<h2>Rust</h2>
<p>We will augment our assembly with code written in
<a href="https://www.rust-lang.org/">Rust</a>. In fact, we will be trying to get to
Rust-land as quickly as we possibly can. Rust is a really great programming
language, and it’s pretty great for writing operating systems. It has some
rough edges, but they’re not too big of a deal.</p>
<p>Rust will allow us to write:</p>
<pre><code class="language-rust">use std::process;

fn main() {
    let mut a = 0;

    for _ in 0..10 {
        a = a + 1;
    }

    process::exit(a);
}
</code></pre>
<p>This does the same thing as our assembly code:</p>
<pre><code class="language-bash">$ rustc lol.rs # compile our Rust code to lol
$ ./lol        # run it
$ echo $?      # print out the exit code
10
$
</code></pre>
<p>That Rust code probably looks more like a programming language you’ve used in
the past. It’s a lot nicer to write complex things in a higher-level
programming language like Rust. That said, virtually all languages are
higher-level than assembly, so that’s not saying all that much. Rust is still a
low-level language by many standards.</p>
<p>So why choose Rust? Well, I’m picking it for two reasons:</p>
<ol>
<li>I love it.</li>
<li>There aren’t a lot of kernels in it yet.</li>
</ol>
<p>There are a suprising number of people working on kernels in Rust. But since
it’s a newer language, there aren’t nearly as many as for older, more
established languages.</p>
<h2>Do I need to be a wizard?</h2>
<p>No, you do not. A common theme of this project is “this is all we’ll need to
know about this topic for now.” There’s no reason that you need to absolutely
master everything before going forward. For example, in order to get Rust
going, we need only about 100 lines of assembly, as mentioned above. Do you
need to be a complete expert in assembly language to understand those well
enough to keep going? Not at all. Will learning more about it help? Absolutely!</p>
<p>There’s nobody that’s monitoring your credentials to see if you’re allowed to
move on. Do it at your own pace. Skip stuff. Come back when you don’t
understand what’s going on. Try it, wait a week, and then try it again.</p>
<p>There’s no wrong way to do this stuff, including by being a beginner. Everyone
was once. Don’t let anyone discourage you.</p>
<h1>Boot -&gt; kmain()</h1>
<p>COMING SOON</p>
<h1>Hello, world!</h1>
<p>COMING SOON</p>
<h1>Keyboard input</h1>
<p>COMING SOON</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
