<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong>1.</strong> Background</a></li><li><ul class="section"><li><a href="what.html"><strong>1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong>1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong>1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong>1.4.</strong> What tools will we use?</a></li></ul></li><li><a href="setup.html"><strong>2.</strong> Setting up a development environment</a></li><li><ul class="section"><li><a href="linux.html"><strong>2.1.</strong> Linux</a></li><li><a href="osx.html"><strong>2.2.</strong> Mac OS X</a></li><li><a href="windows.html"><strong>2.3.</strong> Windows</a></li></ul></li><li><a href="booting-up.html"><strong>3.</strong> Booting up</a></li><li><ul class="section"><li><a href="multiboot-headers.html" class="active"><strong>3.1.</strong> Multiboot headers</a></li><li><a href="hello-world.html"><strong>3.2.</strong> Hello, world!</a></li><li><a href="making-an-iso.html"><strong>3.3.</strong> Making an ISO</a></li><li><a href="running-in-qemu.html"><strong>3.4.</strong> Running in QEMU</a></li><li><a href="automation-with-make.html"><strong>3.5.</strong> Automation with Make</a></li><li><a href="source-control-with-git.html"><strong>3.6.</strong> Source Control with Git</a></li></ul></li><li><a href="transitioning-to-long-mode.html"><strong>4.</strong> Transitioning to Long Mode</a></li><li><a href="a-rust-kmain.html"><strong>5.</strong> A Rust kmain()</a></li><li><a href="simple-vga.html"><strong>6.</strong> A simple VGA driver</a></li><li><a href="keyboard-input.html"><strong>7.</strong> Keyboard input</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">intermezzOS</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Multiboot headers</h1>
<p>Let’s get going! The very first thing we’re going to do is create a ‘multiboot
header’. What’s that, you ask? Well, to explain it, let’s take a small step
back and talk about how a computer boots up.</p>
<p>One of the amazing and terrible things about the x86 architecture is that it’s
maintained backwards compatibility throughout the years. This has been a
competitive advantage, but it’s also meant that the boot process is largely a
pile of hacks. Each time a new iteration comes out, a new step gets added to
the process. That’s right, when your fancy new computer starts up, it thinks
it’s an 8086 from 1976. And then, through a succession of steps, we transition
through more and more modern architectures until we end at the latest and
greatest.</p>
<p>The first mode is called ‘real mode’. This is a 16 bit mode that the original
x86 chips used. The second is ‘protected mode’. This 32 bit mode adds new
things on top of real mode. It’s called ‘protected’ because real mode sort of
let you do whatever you wanted, even if it was a bad idea. Protected mode was
the first time that the hardware enabled certain kinds of protections that allow
us to exercise more control around such things as RAM. We’ll talk more about
those details later.</p>
<p>The final mode is called ‘long mode’, and it’s 64 bits. Well, that’s actually a
lie: there’s two. Initially, you’re not in long mode, you’re in ‘compatibility
mode’. You see, when the industry was undergoing the transition from 32 to 64
bits, there were two options: the first was Intel’s Itanium 64-bit
architecture. It did away with all of the stuff I just told you about. But that
meant that programs had to be completely recompiled from scratch for the new
chips. Intel’s big competitor, AMD, saw an opportunity here, and released a new
set of chips called amd64. These chips were backwards compatible, and so you
could run both 32 and 64 bit programs on them. Itanium wasn’t compelling enough
to make the pain worth it, and so Intel released new chips that were compatible
with amd64. The resulting architecture was then called x86_64, the one we’re
using today. The moral of the story? Intel tried to save you from all of the
stuff we’re about to do, but they failed. So we have to do it.</p>
<p>Where was I... oh yes. Compatibility mode. So when you initially transition
to long mode, you’re not in <em>true</em> long mode; you’re in compatibility mode.
This is the ‘it all both works’ mode. From there, we can transition to
actual, honest-to-goodness long mode.</p>
<p>So that’s the task ahead of us: make the jump up the ladder and get to
long mode. We can do it! Let’s talk more details.</p>
<h2>Firmware and the BIOS</h2>
<p>So let's begin by turning the power to our computer on.</p>
<p>When we press the power button, electricity starts running, and a special piece of
software, known as the BIOS in Intel land, automatically runs.</p>
<p>With the BIOS we're already in the land of software, but unlike software that
you may be used to writing, the BIOS comes bundled with its computer and is located in
<em>r</em>ead-<em>o</em>nly <em>m</em>emory (ROM). While changing or updating stuff in ROM
is possible, it's not something you can do by invoking your favorite
package manager or by downloading something from some website. In fact some ROM
is literally hardwired into the computer and cannot be changed without
physically swapping it out. This makes sense here. The BIOS and the
computer are lifetime partners. Their existence doesn't make much sense without
each other.</p>
<p>One of the first things the BIOS does is run a ‘POST’ or <em>p</em>ower-<em>o</em>n <em>s</em>elf-<em>t</em>est
which checks for the availability and integrity of all the pieces of hardware that
the computer needs including the BIOS itself, CPU registers, RAM, etc. If you've
ever heard a computer beeping at you as it boots up, that's the POST reporting
its findings.</p>
<p>Assuming no problems are found, the BIOS starts the real booting process.</p>
<p>For a while now most commercial computer manufacturers have hidden their BIOS
booting process behind some sort of splash screen. It's usually possible to see the
BIOS' logs by pressing some collection of keys when your computer is starting up.</p>
<p>The BIOS also has a menu where you can see information about the computer
like CPU and memory specs and all the hardware the BIOS detected like hard drives
and CD and DVD drives. Typically this menu is accessed by pressing some other
weird collection of keyboard keys while the computer is attempting to boot.</p>
<p>Next, the BIOS automatically finds a ‘bootable drive’ by looking in certain
pre-determined places like the computer's hard drive and CD and DVD drives.
A drive is ‘bootable’ if it contains software that can finish the booting
process. In the BIOS menu you can usually change in what order the BIOS looks
for bootable drives or tell it to boot from a specific drive.</p>
<p>The BIOS knows it's found a bootable drive by looking at the first few kilobytes
of the drive and looking for some magical numbers set in that drive's
memory. This won't be the last time some magical numbers or hacky sounding things
are used on our way to building an OS. Such is life at such a low level...</p>
<p>When the BIOS has found its bootable drive, it loads part of the drive into
memory and transfers execution to it. With this process, we move away from what
comes dictated by the computer manufacturer and move ever closer to getting our
OS running.</p>
<h2>Bootloaders</h2>
<p>The part of our bootable drive that gets executed is called a ‘bootloader’,
since it loads things at boot time. The bootloader’s job is to take our kernel,
put it into memory, and then transition control to it.</p>
<p>Some people start their operating systems journey by writing a bootloader. We
will not be doing that. Frankly, this whole startup process is more of an
exercise in reading manuals and understanding the history of esoteric hardware
than it is anything else. That stuff may interest you, and maybe someday we’ll
come back and write a bootloader of our own.</p>
<p>In the interest of actually getting around to implementing a kernel, instead, we’ll
use an existing bootloader: GRUB.</p>
<h2>GRUB and Multiboot</h2>
<p>GRUB stands for ‘<em>gr</em>and <em>u</em>nified <em>b</em>ootloader’, and it’s a common one for
GNU/Linux systems. GRUB implements a specification called Multiboot, which is a
set of conventions for how a kernel should get loaded into memory. By following
the Multiboot specification, we can let GRUB load our kernel.</p>
<p>The way that we do this is through a ‘header’. We’ll put some information in a
format that multiboot specifies right at the start of our kernel. GRUB will
read this information, and follow it to do the right thing.</p>
<p>One other advantage of using GRUB: it will handle the transition from real mode
to protected mode for us, skipping the first step. We don’t even need to know
anything about all of that old stuff. If you’re curious about the kinds of
things you would have needed to know, put “A20 pin” into your favorite search
engine, and get ready to cry yourself to sleep.</p>
<h2>Writing our own Multiboot header</h2>
<p>I said we were gonna get to the code, and then I went on about more history.
Sorry about that! It’s code time for real! Let’s make a directory to contain
our project:</p>
<pre><code class="language-bash">$ mkdir intermezzOS
$ cd intermezzOS
</code></pre>
<p>A fun way to follow along is to pick a different name for your kernel, and
then change it as we go. Call your kernel whatever you want. intermezzOS was
almost called ‘Nucleus’, until I found out that there’s already a kernel with
that name that’s installed on billions of embedded devices. Whoops!</p>
<p>Inside that directory, make a new file called <code>multiboot_header.asm</code>, and
open it in your favorite editor. I use <code>vim</code>, but you should feel free to use
anything you’d like.</p>
<pre><code class="language-bash">$ touch multiboot_header.asm
$ vim multiboot_header.asm
</code></pre>
<p>Two notes about this: first of all, we’re just making this source file in the
top level. Don’t worry, we’ll clean house later. Remember: we’re going to build
stuff, and <em>then</em> abstract it afterwards. It’s easier to start with a mess and
clean it up than it is to try to get it perfect on the first try.</p>
<p>Second, this is a <code>.asm</code> file, which is short for ‘assembly’. That’s right, we’re
going to write some assembly code here. Don’t worry! It’s not super hard.</p>
<h3>An aside about assembly</h3>
<p>Have you ever watched Rich Hickey’s talk “Simple vs. Easy”? It’s a wonderful talk.
In it, he draws a distinction between these two words, which are commonly used as
synonyms.</p>
<p>TODO https://github.com/intermezzOS/book/issues/27</p>
<p>Assembly coding is simple, but that doesn’t mean that it’s easy. We’ll be doing
a little bit of assembly programming to build our operating system, but we
don’t need to know <em>that much</em>. It is completely learnable, even for someone
coming from a high-level language. You might need to practice a bit, and take
it slow, but I believe in you. You’ve got this.</p>
<h3>The Magic Number</h3>
<p>Our first assembly file will be almost entirely <em>data</em>, not code. Here’s the
first line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
</code></pre>
<p>Ugh! Gibberish! Let’s start with the semicolon (<code>;</code>). It’s a comment, that
lasts until the end of the line. This particular comment says ‘magic number’.
You’ll be seeing a lot of magic numbers in your operating system work. The idea
of a magic number is that it’s completely and utterly arbitrary. It doesn’t mean
anything. It’s just magic. The very first thing that the multiboot specification
requires is that we have the magic number <code>0xe85250d6</code> right at the start.</p>
<p>What’s the value in having an arbitrary number there? Well, it’s a kind of safeguard
against bad things happening. This is one of the ways in which we can check that
we actually have a real multiboot header. If it doesn’t have the magic number,
something has gone wrong, and we can throw an error.</p>
<p>I have no idea why it’s <code>0xe85250d6</code>, and I don’t need to care. It just is.</p>
<p>Finally, the <code>dd</code>. It’s short for ‘define double word’. It
declares that we’re going to stick some 32-bit data at this location. Very
straightforward.</p>
<h3>The mode code</h3>
<p>Okay, time to add a second line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
dd 0          ; protected mode code
</code></pre>
<p>This is another form of magic number. We want to boot into protected mode, and
so we put a zero here, using <code>dd</code> again. If we wanted GRUB to do something
else, we could look up another code, but this is the one that we want.</p>
<h3>Header length</h3>
<p>The next thing that’s required is a header length. We could use <code>dd</code> and count
out exactly how many bytes that our header is, but there’s two reasons why
we’re not doing that:</p>
<ol>
<li>Computers should do math, not people.</li>
<li>We’re going to add more stuff, and we’d have to recalculate this number each
time. Or wait until the end and come back. See #1.</li>
</ol>
<p>Here’s what this looks like:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length
header_end:
</code></pre>
<p>You don’t have to align the comments if you don’t want to. I usually don’t, but
it looks nice and after we’re done with this file, we’re not going to mess with
it again, so we won’t be constantly re-aligning them in the future.</p>
<p>The <code>header_start:</code> and <code>header_end:</code> things are called ‘labels’. Labels let
us use a name to refer to particular part of our code. Our third <code>dd</code> line
uses those two labels to do some math: the header length is the value of
<code>header_end</code> minus the value of <code>header_start</code>. When we compile this assembly
code, the assembler will do this calculation for us. No need to figure out
how many bytes there are by hand. Awesome.</p>
<p>You’ll also notice that I indented the <code>dd</code> statements. Usually, labels go in
the first column, and you indent actual instructions. How much you indent is up
to you; it’s a pretty flexible format.</p>
<h3>The Checksum</h3>
<p>The fourth field multiboot requires is a ‘checksum’. The idea is that we sum up
some numbers, and then use that number to check that they’re all what we
expected things to be. It’s similar to a hash, in this sense: it lets us and GRUB
double-check that everything is accurate.</p>
<p>Here’s the checksum:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))
header_end:
</code></pre>
<p>Again, we’ll use math to let the computer calculate the sum for us. We add up
the magic number, the mode code, and the header length, and then subtract it
from a big number. <code>dd</code> then puts that value into this spot in our file.</p>
<p>TODO: https://github.com/intermezzOS/book/issues/28</p>
<h3>Ending tag</h3>
<p>After the checksum you can list a series of “tags”, which is a way for the OS to
tell the bootloader to do some extra things before handing control over to the
OS, or to give the OS some extra information once started. We donʼt need any of
that yet, though, so we just need to include the required “end tag”, which looks
like this:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>Here we use <code>dw</code> to define a ‘word’ instead of just data. A word is 2
bytes on the x86_64 architecture. The multiboot specification demands that this
be exactly a word. You’ll find that this is super common in operating systems:
the exact size and amount of everything matters. It’s just a side-effect of
working at a low level.</p>
<h3>The Section</h3>
<p>We have one last thing to do: add a ‘section’ annotation. We’ll talk more about
sections later, so for now, just put what I tell you at the top of the file.</p>
<p>Here’s the final file:</p>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>That’s it! Congrats, you’ve written a multiboot compliant header. It’s a lot of
esoterica, but it’s pretty straightforward once you’ve seen it a few times.</p>
<h2>Assembling with <code>nasm</code></h2>
<p>We can’t use this file directly, we need to turn it into binary. We can use a
program called an ‘assembler’ to ‘assemble’ our assembly code into binary code.
It’s very similar to using a ‘compiler’ to ‘compile’ our source code into
binary. But when it’s assembly, people often use the more specific name.</p>
<p>We will be using an assembler called <code>nasm</code> to do this. You should invoke
<code>nasm</code> like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 multiboot_header.asm
</code></pre>
<p>The <code>-f elf64</code> says that we want to output a <em>f</em>ile with the type <code>elf64</code>.
ELF is a particular executable format that’s used by various UNIX systems,
and we’ll be using it too. There are other formats, but ELF is pretty good.</p>
<p>After you run this command, you should see a <code>multiboot_header.o</code> file in
the same directory. This is our ‘object file’, hence the <code>.o</code>. This is
the binary code, in ELF format. Later, we’ll take this file and use it
to build our OS.</p>
<h2>Summary</h2>
<p>Congratulations! This is the first step towards building an operating system.
We learned about the boot process, the GRUB bootloader, and the Multiboot
specification. We wrote a Multiboot-compliant header file in assembly code, and
used <code>nasm</code> to create an object file from it.</p>
<p>Next, we’ll write the actual code that prints “Hello world” to the screen.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="booting-up.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="hello-world.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="booting-up.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="hello-world.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
